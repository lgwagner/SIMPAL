package com.rockwellcollins.atc.validation;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.EcoreUtil2;

import com.rockwellcollins.atc.limp.AbstractType;
import com.rockwellcollins.atc.limp.ArrayAccessExpr;
import com.rockwellcollins.atc.limp.ArrayExpr;
import com.rockwellcollins.atc.limp.ArrayType;
import com.rockwellcollins.atc.limp.ArrayUpdateExpr;
import com.rockwellcollins.atc.limp.AssignmentStatement;
import com.rockwellcollins.atc.limp.BinaryExpr;
import com.rockwellcollins.atc.limp.BoolType;
import com.rockwellcollins.atc.limp.BooleanLiteralExpr;
import com.rockwellcollins.atc.limp.ChoiceExpr;
import com.rockwellcollins.atc.limp.ConstantDeclaration;
import com.rockwellcollins.atc.limp.DefineUseRef;
import com.rockwellcollins.atc.limp.ElseBlock;
import com.rockwellcollins.atc.limp.ElseIf;
import com.rockwellcollins.atc.limp.EnumType;
import com.rockwellcollins.atc.limp.EnumTypeDef;
import com.rockwellcollins.atc.limp.EnumValue;
import com.rockwellcollins.atc.limp.Expr;
import com.rockwellcollins.atc.limp.ExternalFunction;
import com.rockwellcollins.atc.limp.ExternalProcedure;
import com.rockwellcollins.atc.limp.FcnCallExpr;
import com.rockwellcollins.atc.limp.ForStatement;
import com.rockwellcollins.atc.limp.FunctionRef;
import com.rockwellcollins.atc.limp.GlobalDeclaration;
import com.rockwellcollins.atc.limp.IdExpr;
import com.rockwellcollins.atc.limp.IdList;
import com.rockwellcollins.atc.limp.IfThenElseExpr;
import com.rockwellcollins.atc.limp.IfThenElseStatement;
import com.rockwellcollins.atc.limp.InitExpr;
import com.rockwellcollins.atc.limp.InputArg;
import com.rockwellcollins.atc.limp.IntegerLiteralExpr;
import com.rockwellcollins.atc.limp.IntegerType;
import com.rockwellcollins.atc.limp.IntegerWildCardExpr;
import com.rockwellcollins.atc.limp.LimpFactory;
import com.rockwellcollins.atc.limp.LimpPackage;
import com.rockwellcollins.atc.limp.LocalArg;
import com.rockwellcollins.atc.limp.LocalFunction;
import com.rockwellcollins.atc.limp.LocalProcedure;
import com.rockwellcollins.atc.limp.NamedType;
import com.rockwellcollins.atc.limp.OutputArg;
import com.rockwellcollins.atc.limp.Postcondition;
import com.rockwellcollins.atc.limp.Precondition;
import com.rockwellcollins.atc.limp.RealLiteralExpr;
import com.rockwellcollins.atc.limp.RealType;
import com.rockwellcollins.atc.limp.RecordAccessExpr;
import com.rockwellcollins.atc.limp.RecordExpr;
import com.rockwellcollins.atc.limp.RecordFieldType;
import com.rockwellcollins.atc.limp.RecordType;
import com.rockwellcollins.atc.limp.RecordTypeDef;
import com.rockwellcollins.atc.limp.RecordUpdateExpr;
import com.rockwellcollins.atc.limp.SecondInit;
import com.rockwellcollins.atc.limp.Statement;
import com.rockwellcollins.atc.limp.StatementBlock;
import com.rockwellcollins.atc.limp.StringLiteralExpr;
import com.rockwellcollins.atc.limp.StringType;
import com.rockwellcollins.atc.limp.TupleType;
import com.rockwellcollins.atc.limp.Type;
import com.rockwellcollins.atc.limp.UnaryMinusExpr;
import com.rockwellcollins.atc.limp.UnaryNegationExpr;
import com.rockwellcollins.atc.limp.VariableRef;
import com.rockwellcollins.atc.limp.VoidStatement;
import com.rockwellcollins.atc.limp.VoidType;
import com.rockwellcollins.atc.limp.WhileStatement;
import com.rockwellcollins.atc.limp.util.LimpSwitch;
import com.rockwellcollins.atc.limp.utils.GetFunctionName;

/**
 * LimpTypeChecker extends the XText autogenerated LimpSwitch class and provides a type-checking
 * for the Limp language.  It is invoked automatically from the LimpJavaValidator on various objects
 * in the Limp grammar.
 * 
 *  In general, the LimpTypeChecker will validate that a grammar production is type-correct
 *  (for example, both sides of a binary expression have arguments of the same type) and return
 *  that type.  If there is type disagreement, an error is flagged and shown in the editor,
 *  and an ErrorType is returned.
 */
public class LimpTypeChecker extends LimpSwitch<Type> {

	/**
	 * The LimpFactory is used to create new Limp elements.  For example, when a BooleanLiteralExpression is encountered, the type checker will 
	 * return a BoolType, which is accomplished by invoking the createBoolType() method of the LimpFactory.
	 */
	private LimpFactory f = LimpFactory.eINSTANCE;
	
	/**
	 * The LimpJavaValidator is the validator that is invoking the typechecker.  This is stored so we can access the error/warning calling methods
	 * to display type errors to the user in the editor.
	 */
	private LimpJavaValidator v;
	
	/**
	 * The LimpTypeChecker must be provided the current LimpJavaValidator on instantiation. 
	 */
	public LimpTypeChecker(LimpJavaValidator ljv) {
		super();
		v = ljv;
	}
	
	/**
	 * A locally used method to call the validator's error method with the appropriate arguments. 
	 */
	private void error(String msg, EObject obj) {
		if(this != null) {
			v.error(msg, obj);
		}
	}
	
	/**
	 * A locally used method to call the validator's error method with the appropriate arguments. 
	 */
	private void error(String message, EObject source, EStructuralFeature feature) {
		v.error(message, source, feature);
	}

	/**
	 * A locally used method to call the validator's error method with the appropriate arguments. 
	 */
	private void error(String message, EObject source, EStructuralFeature feature, int index) {
		v.error(message, source, feature, index);
	}
	
	/**
	 * Returns the type of an InputArg
	 */
	@Override
	public Type caseInputArg(InputArg iarg) {
		Type t = EcoreUtil2.copy(iarg.getType());
		return t;
	}
	
	/**
	 * Returns the type of an LocalArg
	 */
	@Override
	public Type caseLocalArg(LocalArg larg) {
		Type t = EcoreUtil2.copy(larg.getType());
		return t;
	}

	/**
	 * Returns the type of an OutputArg
	 */
	@Override
	public Type caseOutputArg(OutputArg oarg) {
		Type t = EcoreUtil2.copy(oarg.getType());
		return t;
	}

	/**
	 * Returns the type of an ConstantDeclaration
	 */
	@Override
	public Type caseConstantDeclaration(ConstantDeclaration cd) {
		Type t = EcoreUtil2.copy(cd.getType());
		return t;
	}

	/**
	 * Returns the type of an GlobalDeclaration
	 */
	@Override
	public Type caseGlobalDeclaration(GlobalDeclaration gd) {
		Type t = EcoreUtil2.copy(gd.getType());
		return t;
	}
	
	/**
	 * Typechecks all of the statements of a statement block
	 */
	@Override
	public Type caseStatementBlock(StatementBlock sb) {
		for(Statement s : sb.getStatements()) {
			this.doSwitch(s);
		}
		return null;
	}
	
	/**
	 * Computes the type of a ChoiceExpr.
	 */
	@Override
	public Type caseChoiceExpr(ChoiceExpr choice) {
		Type first = this.doSwitch(choice.getFirst());
		Type second = this.doSwitch(choice.getSecond());
		
		if(!typeEquals(first,second)) {
			error("Types of a choice expression must be equivalent.", choice);
			return null;
		} else {
			return first;	
		}
	}
	
	/**
	 * Computes the type of a StatementBlock (for IfThenElse, While, For statements)
	 */
	@Override
	public Type caseIfThenElseStatement(IfThenElseStatement ites) {
		Type condType = this.doSwitch(ites.getCond());
		
		if(!(condType instanceof BoolType)) {
			error("IfThenElse condition must be of type boolean.", ites.getCond());
		}
		
		this.doSwitch(ites.getThenBlock());
		this.doSwitch(ites.getElse());
		return null;
	}
	
	/**
	 * Computes the type of an ElseBlock
	 */
	@Override
	public Type caseElseBlock(ElseBlock eb) {
		return this.doSwitch(eb.getBlock());
	}
	
	/**
	 * Computes the type of an ElseIf 
	 */
	@Override
	public Type caseElseIf(ElseIf ei) {
		return this.doSwitch(ei.getIfThenElse());
	}
	
	/**
	 * Computes the type of the VoidStatement expression and does the following:
	 * 
	 * if the type is a VoidType returns it
	 * if the type is not VoidType, it flags an error and returns ErrorType
	 */
	@Override
	public Type caseVoidStatement(VoidStatement vs) {
		Type exprType = this.doSwitch(vs.getExpr());
		if(exprType == null) {
			return null;
		}
		
		if(exprType instanceof VoidType) {
			return exprType;
		} else {
			error("VoidStatements must return type Void.", vs);
			return null;
		}
	}
	
	/**
	 * Computes the type of the AssignmentStatement left hand side, and right hand side.
	 * 
	 * If the LHS and RHS types agree, it returns the LHS type (this is arbitrary and shouldn't be used)
	 * If the LHS and RHS do not agree, it flags the error, and returns ErrorType
	 */
	@Override
	public Type caseAssignmentStatement(AssignmentStatement as) {
		Type lhsType = this.doSwitch(as.getIds());
		Type rhsType = this.doSwitch(as.getRhs());
		
		if(lhsType == null || rhsType == null) {
			return null;
		}
		
		if(!typeEquals(lhsType,rhsType)) {
			error("Assigned ID and right hand side type do not agree.", as);
			return null;
		} else {
			return lhsType;
		}
	}
	
	/**
	 * Typechecks a WhileStatement
	 */
	@Override
	public Type caseWhileStatement(WhileStatement ws) {
		Type condType = this.doSwitch(ws.getCond());
		
		if(!(condType instanceof BoolType)) {
			error("WhileStatement conditional must be of type boolean.", ws.getCond());
		}
		return this.doSwitch(ws.getBlock());
	}
	
	/**
	 * Type checks a ForStatement
	 */
	@Override
	public Type caseForStatement(ForStatement fs) {
		return this.doSwitch(fs.getBlock());
	}
	
	/**
	 * Returns the type of an IDList as a LHSType, because an IDList is always the
	 * left hand side of an assignment statement.
	 */
	@Override
	public Type caseIdList(IdList idl) {
		TupleType tupleType = f.createTupleType();
		for(VariableRef vr : idl.getIds()) {
			Type t = this.doSwitch(vr);
			if(t != null) {
				tupleType.getTypeList().add(t);	
			}
		}
		assert tupleType.getTypeList().size() > 0;
		
		if(tupleType.getTypeList().size() == 1) {
			return tupleType.getTypeList().get(0);
		} else {
			return tupleType;			
		}
	}
	
	/**
	 * Checks that the type of the condition expr is a boolean, and that the 
	 * then and else exprs match.
	 */
	@Override
	public Type caseIfThenElseExpr(IfThenElseExpr ite) {
		Type condType = this.doSwitch(ite.getCondExpr());
		Type thenType = this.doSwitch(ite.getThenExpr());
		Type elseType = this.doSwitch(ite.getElseExpr());
		
		if(!(condType instanceof BoolType)) {
				error("IfThenElseExpr must have boolean types in the test condition",ite.getCondExpr());
				return null;
		}
		
		if(typeEquals(thenType,elseType)) {
			return thenType;
		} else {
			error("IfThenElseExpr ThenExpr and ElseExpr must be of the same type.", ite);
			return null;
		}
	}
	
	/**
	 * Checks that the types of both sides of an binary expression agree, and are in agreement
	 * with the operator.
	 * 
	 * If there is type agreement, that type is returned.
	 * If there is not type agreement, an error is flagged and an ErrorType is returned.
	 * 
	 * Calling this method on the following expressions
	 * 		5 + 3 is type correct and would return an IntType
	 * 		5 + true is type incorrect and would return an ErrorType
	 * 		true + false is type incorrect for the "+" operator and would return an ErrorType
	 * 		true and false is type correct and would return a BoolType
	 */
	@Override
	public Type caseBinaryExpr(BinaryExpr be) {
		 Type left = doSwitch(be.getLeft());
		 Type right = doSwitch(be.getRight());
		 
		 if(left == null | right == null) {
			 return null;
		 }
		 
		 if(!typeEquals(left,right)) {
			 error("Types of a binary expression must be equivalent.", be);
		 }
		 
		 if(be.getOp().equals("+") || 
			be.getOp().equals("-") || 
			be.getOp().equals("*") || 
			be.getOp().equals("/")) {
			 
			 if(left instanceof BoolType || right instanceof BoolType) {
				error("Arithmetic operations may not be performed on boolean types.", be);
				return null;
			} else {
				return left;
			}
		 }
		 
		 if(be.getOp().equals("==") || 
			be.getOp().equals("<>")) {
			 if(!this.typeEquals(left, right)) {
				 error("Equivalence operations may not be performed on boolean types.", be);
				 return null;
			 } else {
				 BoolType boolType = f.createBoolType();
				 return boolType;
			 }
		 }
		 
		 if(be.getOp().equals("<") ||
			be.getOp().equals("<=") ||
			be.getOp().equals(">") ||
			be.getOp().equals(">=")) {
			 
			 if(left instanceof BoolType || right instanceof BoolType) {
				 error("Relational operations may not be performed on boolean types.", be);
				 return null;
			 } else {
				 BoolType boolType = f.createBoolType();
				 return boolType;
			 }
		 }
		 
		 if(be.getOp().equals("=>") ||
			be.getOp().equals("or") || 
			be.getOp().equals("and")) {
			 if(left instanceof IntegerType || 
				left instanceof RealType ||
				right instanceof IntegerType || 
				right instanceof RealType) {
				 error("Logical operations may not be performed on Real or Integer types.", be);
				 return null;
			 } else {
				 return left;
			 }
		 }
		 
		 error("Unexpected BinaryOperator.", be);
		 return null;
	}
	
	/**
	 * Computes the type of the subexpression and then checks the
	 * type is arithmetic (either real, or integer) and returns that type.
	 * 
	 * If the type is not arithmetic, ErrorType is returned.
	 */
	@Override
	public Type caseUnaryMinusExpr(UnaryMinusExpr ume) {
		Type subType = doSwitch(ume.getExpr());

		if (subType instanceof IntegerType || subType instanceof RealType) {
			return subType;
		}
		
		error("Applying a negation to a non-arithmetic type is illegal.", ume.getExpr());
		return null;
	}
	
	/**
	 * Computes the type of the subexpression and then checks if the
	 * type is boolean and returns that type.
	 * 
	 * If the type is not boolean, ErrorType is returned.
	 */
	@Override
	public Type caseUnaryNegationExpr(UnaryNegationExpr une) {
		Type baseType = doSwitch(une.getExpr());
		
		if (baseType instanceof BoolType) {
			return baseType;
		}
		
		error("Applying a boolean negation to a non boolean expression is illegal.", une.getExpr());
		return null;
	}
	
	/**
	 * Computes the type of an InitExpr, which is just the type of the
	 * subExpr.
	 */
	@Override
	public Type caseInitExpr(InitExpr ie) {
		return doSwitch(ie.getId());
	}
	
	/**
	 * Computes the type of a SecondInitExpr, which is just hte type of the subExpr
	 */
	@Override
	public Type caseSecondInit(SecondInit sinit) {
		return doSwitch(sinit.getId());
	}
	
	/**
	 * When a record literal expression is encountered a record type is created 
	 * with fields that occur in the record expression, and types of each field
	 * assigned to the expression inferred from each field.
	 * 
	 * If a field type is not a LimpType, an ErrorType is returned.
	 */	
	@Override
	public Type caseRecordExpr(RecordExpr re) {
		RecordType rt = f.createRecordType();
		rt.setRecordDef(EcoreUtil2.copy(re.getRecordDefinition()));
		return rt;
	}
	
	/**
	 * Computes the type of the base expression and returns the type of the indexed field.
	 * 
	 * If the base expression is not a tuple, it returns ErrorType
	 * If the base expression is a record and does not contain the referenced field, it returns ErrorType
	 */
	@Override
	public Type caseRecordAccessExpr(RecordAccessExpr rae) {
		Type record = this.doSwitch(rae.getRecord());
				
		if (record == null) {
			return null;
		}
		
		if (record instanceof RecordType) {
			RecordType recordType = (RecordType) record;
			Map<String,Type> recordMap = createMapFromRecord(recordType.getRecordDef());
			Type t = recordMap.get(rae.getField());
			if(t == null) {
				error("Field " + rae.getField() + " is not defined in this RecordType", rae, LimpPackage.Literals.RECORD_ACCESS_EXPR__FIELD);
				return null;
			}
			return EcoreUtil2.copy(t);
		}
		error("Field index expressions may only be used on Record Expressions", rae, LimpPackage.Literals.RECORD_ACCESS_EXPR__FIELD);
		return null;
	}

	/**
	 *  Ensures the update Expr is the correct type, and returns the record type.
	 */
	@Override
	public Type caseRecordUpdateExpr(RecordUpdateExpr rue) {
		Type record = this.doSwitch(rue.getRecord());
		Type value = this.doSwitch(rue.getValue());
		
		if(record == null || value == null) {
			return null;
		}

		if (record instanceof RecordType) {
			RecordType recordType = (RecordType) record;
			Map<String,Type> recordMap = createMapFromRecord(recordType.getRecordDef());
			Type t = recordMap.get(rue.getField());
			
			if(t == null) {
				error("Field " + rue.getField() + " is not defined in this record.", rue, LimpPackage.Literals.RECORD_ACCESS_EXPR__FIELD);
			}
			
			if(typeEquals(t,value)) {
				return EcoreUtil2.copy(record);
			} else {
				error("Field " + rue.getField() + " is being assigned a conflicting type.", rue.getValue());
				return null;
			}
		}
		
		error("RecordUpdate expressions may only be performed on RecordTypes", rue, LimpPackage.Literals.RECORD_UPDATE_EXPR__RECORD);
		return null;
	}
	
	/**
	 * When an array literal expression is encountered an array type with the
	 * base type of array set to the type of the last type.
	 * 
	 * If an element is of a different type than the rest, an ErrorType is returned.
	 */
	@Override
	public Type	caseArrayExpr(ArrayExpr ae) {
		ArrayType at = f.createArrayType();
		at.setArrayDef(EcoreUtil2.copy(ae.getArrayDefinition()));
		return at;
	}
	
	/**
	 * Computes the type of the base expression and returns the type of the indexed field.
	 * 
	 * If the base expression is not a tuple or an array it returns ErrorType.
	 * If the base expression is referenced by any expression other than an integer literal ErrorType is returned.
	 * If the base expression is referenced by an integer literal expression that is not a legal index, ErrorType is returned.
	 */
	@Override
	public Type caseArrayAccessExpr(ArrayAccessExpr aae) {
		Type array = this.doSwitch(aae.getArray());
		Type index = this.doSwitch(aae.getIndex());
		
		if (array == null || index == null) {
			return null;
		}
		
		if(array instanceof ArrayType) {
			ArrayType arrayType = (ArrayType) array;
			if(index instanceof IntegerType) {
				return EcoreUtil2.copy(arrayType.getArrayDef().getBaseType());
			} else {
				error("Array expressions may only be indexed by integer expressions.", aae.getIndex());
				return null;
			}
		}
		
		error("ArrayAccess expressions may only be performed on ArrayTypes.", aae.getArray());
		return null;
	}
	
	/**
	 * Computes the type of of the array access and makes sure the value being assigned
	 * is correct for the array type.
	 */
	@Override
	public Type caseArrayUpdateExpr(ArrayUpdateExpr aue) {
		Type array = this.doSwitch(aue.getAccess().getArray());
		Type index = this.doSwitch(aue.getAccess().getIndex());
		Type value = this.doSwitch(aue.getValue());
		
		if(array == null || index == null || value == null) {
			return null;
		}
		
		if(array instanceof ArrayType) {
			ArrayType arrayType = (ArrayType) array;
			if(index instanceof IntegerType) {
				if(typeEquals(arrayType.getArrayDef().getBaseType(),value)) {
					return EcoreUtil2.copy(arrayType);
				} else {
					error("Update expression does not match array element type", aue.getValue());
					return null;
				}
			} else {
				error("Array expressions may only be indexed by integer expressions.", aue.getAccess().getIndex());
				return null;
			}
		}

		error("Only array expressions can be updated with an ArrayUpdate expression.", aue.getAccess().getArray());
		return null;
	}
	
	/**
	 * When a boolean literal expression is encountered, a boolean type is always returned.
	 */
	@Override
	public Type caseBooleanLiteralExpr(BooleanLiteralExpr ble) {
		return f.createBoolType();
	}

	/**
	 * When a boolean literal expression is encountered, a boolean type is always returned.
	 */
	@Override
	public Type caseIntegerWildCardExpr(IntegerWildCardExpr iwce) {
		return f.createIntegerType();
	}
	
	/**
	 * When an integer literal expression is encountered, an integer type is always returned.
	 */
	@Override
	public Type caseIntegerLiteralExpr(IntegerLiteralExpr ile) {
		return f.createIntegerType();
	}
	
	/**
	 * When an real literal expression is encountered, an real type is always returned.
	 */
	@Override
	public Type caseRealLiteralExpr(RealLiteralExpr ile) {
		return f.createRealType();
	}
	
	/**
	 * When a string literal expression is encountered, a string type is always returned.
	 */
	@Override
	public Type caseStringLiteralExpr(StringLiteralExpr sle) {
		return f.createStringType();
	}

	/**
	 * Returns the type of the VariableRef referenced by the IdExpr 
	 */
	@Override
	public Type caseIdExpr(IdExpr ide) {
		VariableRef id = ide.getId();
		return doSwitch(id);
	}
	
	@Override
	public Type caseEnumValue(EnumValue ev) {
		EnumTypeDef etd = (EnumTypeDef) ev.eContainer();
		EnumType type = f.createEnumType();
		type.setEnumDef(etd);
		return type;
	}

	private List<InputArg> getInputArgs(FunctionRef fr) {
		List<InputArg> inputArgs = null;
		if (fr instanceof ExternalFunction) {
			ExternalFunction ef = (ExternalFunction) fr;
			inputArgs = new ArrayList<>(ef.getInputs().getInputArgs());
		} else if (fr instanceof LocalFunction) {
			LocalFunction lf = (LocalFunction) fr;
			inputArgs = new ArrayList<>(lf.getInputs().getInputArgs());
		} else if (fr instanceof ExternalProcedure) {
			ExternalProcedure ep = (ExternalProcedure) fr;
			inputArgs = new ArrayList<>(ep.getInputs().getInputArgs());
		} else if (fr instanceof LocalProcedure) {
			LocalProcedure lp = (LocalProcedure) fr;
			inputArgs = new ArrayList<>(lp.getInputs().getInputArgs());
		}
		return inputArgs;
	}
	
	private List<OutputArg> getOutputArgs(FunctionRef fr) {
		List<OutputArg> outputArgs = null;
		if (fr instanceof ExternalFunction) {
			ExternalFunction ef = (ExternalFunction) fr;
			outputArgs = Collections.singletonList(ef.getOutput());
		} else if (fr instanceof LocalFunction) {
			LocalFunction lf = (LocalFunction) fr;
			outputArgs = Collections.singletonList(lf.getOutput());
		} else if (fr instanceof ExternalProcedure) {
			ExternalProcedure ep = (ExternalProcedure) fr;
			outputArgs = new ArrayList<>(ep.getOutputs().getOutputArgs());
		} else if (fr instanceof LocalProcedure) {
			LocalProcedure lp = (LocalProcedure) fr;
			outputArgs = new ArrayList<>(lp.getOutputs().getOutputArgs());
		}
		return outputArgs;
	}
	
	/**
	 * Checks the input expressions type match the Function's input types and returns ErrorType 
	 * if there are discrepancies.
	 * 
	 */
	@Override
	public Type caseFcnCallExpr(FcnCallExpr fce) {
		
		FunctionRef fr = fce.getId();
		List<Expr> callArgs = new ArrayList<>(fce.getExprs().getExprList());
		List<InputArg> inputArgs = getInputArgs(fr);
		List<OutputArg> outputArgs = getOutputArgs(fr);

		if(callArgs.size() != inputArgs.size()) {
			error("External Function " + GetFunctionName.getName(fr) + " is called with " + callArgs.size() + " but requires " + inputArgs.size(), fce);
		} else {
			for(int i=0; i<callArgs.size(); i++) {
				Type callArg = this.doSwitch(callArgs.get(i));
				Type inputArg = inputArgs.get(i).getType();
				if(!typeEquals(callArg,inputArg)) {
					error("Argument " + i + " disagress with specified type.", fce, LimpPackage.Literals.FCN_CALL_EXPR__EXPRS, i);
				}
			}
		}
		
		if(outputArgs.size() == 0) {
			VoidType voidType = f.createVoidType();
			return voidType;
		}
		
		if(outputArgs.size() == 1) {
			return outputArgs.get(0).getType();
		}
		
		if(outputArgs.size() > 1) {
			TupleType tt = f.createTupleType();
			for(OutputArg oarg : outputArgs) {
				Type t = EcoreUtil2.copy(oarg.getType());
				tt.getTypeList().add(t);
			}
			return tt;
		}
		
		//if the outputArgs.size < 0 then return null;
		//yeah i know it doesn't make sense.
		return null;
	}
	
	/**
	 * Type checking Preconditions
	 */
	@Override
	public Type casePrecondition(Precondition pre) {
		Type exprType = doSwitch(pre.getExpr());
		
		if(exprType == null) {
			return null;
		}
		
		if(exprType instanceof BoolType) {
			return exprType;
		} else {
			error("Preconditions must be boolean typed.",pre.getExpr());
			return null;
		}
	}

	/**
	 * Type checking Postconditions
	 */
	@Override
	public Type casePostcondition(Postcondition post) {
		Type exprType = doSwitch(post.getExpr());
		
		if(exprType == null) {
			return null;
		}
		
		if(exprType instanceof BoolType) {
			return exprType;
		} else {
			error("Preconditions must be boolean typed.",post.getExpr());
			return null;
		}
	}	
	
	/**
	 * Type checking DefineUseRef
	 */
	@Override
	public Type caseDefineUseRef(DefineUseRef ref) {
		return doSwitch(ref.getReferenceExpr());
	}

	/*
	/**
	 * In the case a function has not been defined for an specific expression, this method will
	 * catch it, flag an error, and return an ErrorType.
	 * 
	 * This is useful for catching errors if additional expressions are added.
	 
	@Override
	public Type caseExpr(Expr e) {
		if(e != null) {
			error("Unexpected expr object" + e.toString() + " encountered while type checking.", e);
		}
		return null;
	}
	*/ 
	
	/**
	 * Creates a TreeMap from a RecordType.
	 */
	private TreeMap<String,Type> createMapFromRecord(RecordTypeDef rtd) {
		TreeMap<String,Type> rmap = new TreeMap<String,Type>();
		for(RecordFieldType rft : rtd.getFields()) {
			rmap.put(rft.getFieldName(), rft.getFieldType());
		}
		return rmap;
	}
	

	/**
	 * Checks if two native LimpTypes (subType is just a regular Type) are equivalent
	 * 
	 * Note: Structurally equivalent types are only equivalent if their names are also identical.
	 */
	public boolean typeEquals(Type t1, Type t2) {
		if(t1 == null || t2 == null) {
			return false;
		}

		if(t1 instanceof VoidType && t2 instanceof VoidType) {
			return true;
		}

		if(t1 instanceof BoolType && t2 instanceof BoolType) {
			return true;
		}
		
		if(t1 instanceof IntegerType && t2 instanceof IntegerType) {
			return true;
		}
		
		if(t1 instanceof RealType && t2 instanceof RealType) {
			return true;
		}
		
		if(t1 instanceof StringType && t2 instanceof StringType) {
			return true;
		}
		
		if(t1 instanceof EnumType && t2 instanceof EnumType) {
			EnumType et1 = (EnumType) t1;
			EnumType et2 = (EnumType) t2;
			return et1.getEnumDef().getName().equals(et2.getEnumDef().getName());
		}
		
		if(t1 instanceof RecordType && t2 instanceof RecordType) {
			RecordType record1 = (RecordType) t1;
			RecordType record2 = (RecordType) t2;
			return record1.getRecordDef().getName().equals(record2.getRecordDef().getName());
		}
		
		if(t1 instanceof ArrayType && t2 instanceof ArrayType) {
			ArrayType array1 = (ArrayType) t1;
			ArrayType array2 = (ArrayType) t2;
			return array1.getArrayDef().getName().equals(array2.getArrayDef().getName());
		}
		
		if(t1 instanceof TupleType && t2 instanceof TupleType) {
			TupleType tt1 = (TupleType) t1;
			TupleType tt2 = (TupleType) t2;
			
			if(tt1.getTypeList().size() != tt2.getTypeList().size()) {
				return false;
			} else {
				for(int i=0; i<tt1.getTypeList().size(); i++) {
					Type subType1 = tt1.getTypeList().get(i);
					Type subType2 = tt2.getTypeList().get(i);
					if(!typeEquals(subType1,subType2)) {
						return false;
					}
				}
				return true;
			}
				
		}
		
		if(t1 instanceof AbstractType && t2 instanceof AbstractType) {
			AbstractType abstract1 = (AbstractType) t1;
			AbstractType abstract2 = (AbstractType) t2;
			return abstract1.getAbstractDef().getName().equals(abstract2.getAbstractDef().getName());
		}
		
		if(t1 instanceof NamedType) {
			NamedType nt1 = (NamedType) t1;
			return typeEquals(nt1.getAlias().getType(),t2);
		}
		
		if(t2 instanceof NamedType) {
			NamedType nt2 = (NamedType) t2;
			return typeEquals(t1,nt2.getAlias().getType());
		}
		return false;
	}
}
