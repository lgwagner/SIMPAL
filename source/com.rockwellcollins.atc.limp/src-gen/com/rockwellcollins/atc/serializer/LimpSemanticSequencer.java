/*
 * generated by Xtext
 */
package com.rockwellcollins.atc.serializer;

import com.google.inject.Inject;
import com.rockwellcollins.atc.limp.AbstractType;
import com.rockwellcollins.atc.limp.AbstractTypeDef;
import com.rockwellcollins.atc.limp.ArrayAccessExpr;
import com.rockwellcollins.atc.limp.ArrayExpr;
import com.rockwellcollins.atc.limp.ArrayType;
import com.rockwellcollins.atc.limp.ArrayTypeDef;
import com.rockwellcollins.atc.limp.ArrayUpdateExpr;
import com.rockwellcollins.atc.limp.AssignmentStatement;
import com.rockwellcollins.atc.limp.BinaryExpr;
import com.rockwellcollins.atc.limp.BoolType;
import com.rockwellcollins.atc.limp.BooleanLiteralExpr;
import com.rockwellcollins.atc.limp.BreakStatement;
import com.rockwellcollins.atc.limp.ChoiceExpr;
import com.rockwellcollins.atc.limp.Comment;
import com.rockwellcollins.atc.limp.ConstantDeclaration;
import com.rockwellcollins.atc.limp.ContinueStatement;
import com.rockwellcollins.atc.limp.Define;
import com.rockwellcollins.atc.limp.DefineUseRef;
import com.rockwellcollins.atc.limp.ElseBlock;
import com.rockwellcollins.atc.limp.ElseIf;
import com.rockwellcollins.atc.limp.EnumType;
import com.rockwellcollins.atc.limp.EnumTypeDef;
import com.rockwellcollins.atc.limp.EnumValue;
import com.rockwellcollins.atc.limp.EquationBlock;
import com.rockwellcollins.atc.limp.ExprList;
import com.rockwellcollins.atc.limp.ExternalFunction;
import com.rockwellcollins.atc.limp.ExternalProcedure;
import com.rockwellcollins.atc.limp.FcnCallExpr;
import com.rockwellcollins.atc.limp.ForStatement;
import com.rockwellcollins.atc.limp.FreshVariable;
import com.rockwellcollins.atc.limp.GlobalDeclaration;
import com.rockwellcollins.atc.limp.GotoStatement;
import com.rockwellcollins.atc.limp.IdExpr;
import com.rockwellcollins.atc.limp.IdList;
import com.rockwellcollins.atc.limp.IfThenElseExpr;
import com.rockwellcollins.atc.limp.IfThenElseStatement;
import com.rockwellcollins.atc.limp.Import;
import com.rockwellcollins.atc.limp.InitExpr;
import com.rockwellcollins.atc.limp.InputArg;
import com.rockwellcollins.atc.limp.InputArgList;
import com.rockwellcollins.atc.limp.IntegerLiteralExpr;
import com.rockwellcollins.atc.limp.IntegerType;
import com.rockwellcollins.atc.limp.IntegerWildCardExpr;
import com.rockwellcollins.atc.limp.LabelStatement;
import com.rockwellcollins.atc.limp.LimpPackage;
import com.rockwellcollins.atc.limp.LocalArg;
import com.rockwellcollins.atc.limp.LocalFunction;
import com.rockwellcollins.atc.limp.LocalProcedure;
import com.rockwellcollins.atc.limp.NamedType;
import com.rockwellcollins.atc.limp.NoAttributeBlock;
import com.rockwellcollins.atc.limp.NoElse;
import com.rockwellcollins.atc.limp.NoVarBlock;
import com.rockwellcollins.atc.limp.OutputArg;
import com.rockwellcollins.atc.limp.OutputArgList;
import com.rockwellcollins.atc.limp.Postcondition;
import com.rockwellcollins.atc.limp.Precondition;
import com.rockwellcollins.atc.limp.RealLiteralExpr;
import com.rockwellcollins.atc.limp.RealType;
import com.rockwellcollins.atc.limp.RecordAccessExpr;
import com.rockwellcollins.atc.limp.RecordExpr;
import com.rockwellcollins.atc.limp.RecordFieldExpr;
import com.rockwellcollins.atc.limp.RecordFieldType;
import com.rockwellcollins.atc.limp.RecordType;
import com.rockwellcollins.atc.limp.RecordTypeDef;
import com.rockwellcollins.atc.limp.RecordUpdateExpr;
import com.rockwellcollins.atc.limp.ReturnStatement;
import com.rockwellcollins.atc.limp.SecondInit;
import com.rockwellcollins.atc.limp.SomeAttributeBlock;
import com.rockwellcollins.atc.limp.SomeVarBlock;
import com.rockwellcollins.atc.limp.Specification;
import com.rockwellcollins.atc.limp.StatementBlock;
import com.rockwellcollins.atc.limp.StringLiteralExpr;
import com.rockwellcollins.atc.limp.StringType;
import com.rockwellcollins.atc.limp.TupleType;
import com.rockwellcollins.atc.limp.TypeAlias;
import com.rockwellcollins.atc.limp.UnaryMinusExpr;
import com.rockwellcollins.atc.limp.UnaryNegationExpr;
import com.rockwellcollins.atc.limp.Uses;
import com.rockwellcollins.atc.limp.VoidStatement;
import com.rockwellcollins.atc.limp.VoidType;
import com.rockwellcollins.atc.limp.WhileStatement;
import com.rockwellcollins.atc.services.LimpGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class LimpSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LimpGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == LimpPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LimpPackage.ABSTRACT_TYPE:
				sequence_Type(context, (AbstractType) semanticObject); 
				return; 
			case LimpPackage.ABSTRACT_TYPE_DEF:
				sequence_AbstractTypeDef(context, (AbstractTypeDef) semanticObject); 
				return; 
			case LimpPackage.ARRAY_ACCESS_EXPR:
				sequence_AccessExpr(context, (ArrayAccessExpr) semanticObject); 
				return; 
			case LimpPackage.ARRAY_EXPR:
				sequence_ArrayExpr(context, (ArrayExpr) semanticObject); 
				return; 
			case LimpPackage.ARRAY_TYPE:
				sequence_Type(context, (ArrayType) semanticObject); 
				return; 
			case LimpPackage.ARRAY_TYPE_DEF:
				sequence_ArrayTypeDef(context, (ArrayTypeDef) semanticObject); 
				return; 
			case LimpPackage.ARRAY_UPDATE_EXPR:
				sequence_AccessExpr(context, (ArrayUpdateExpr) semanticObject); 
				return; 
			case LimpPackage.ASSIGNMENT_STATEMENT:
				sequence_AssignmentStatement(context, (AssignmentStatement) semanticObject); 
				return; 
			case LimpPackage.BINARY_EXPR:
				sequence_AndExpr_ImpliesExpr_MultExpr_OrExpr_PlusExpr_RelationalExpr(context, (BinaryExpr) semanticObject); 
				return; 
			case LimpPackage.BOOL_TYPE:
				sequence_Type(context, (BoolType) semanticObject); 
				return; 
			case LimpPackage.BOOLEAN_LITERAL_EXPR:
				sequence_TerminalExpr(context, (BooleanLiteralExpr) semanticObject); 
				return; 
			case LimpPackage.BREAK_STATEMENT:
				sequence_Statement(context, (BreakStatement) semanticObject); 
				return; 
			case LimpPackage.CHOICE_EXPR:
				sequence_ChoiceExpr(context, (ChoiceExpr) semanticObject); 
				return; 
			case LimpPackage.COMMENT:
				sequence_Comment(context, (Comment) semanticObject); 
				return; 
			case LimpPackage.CONSTANT_DECLARATION:
				sequence_ConstantDeclaration(context, (ConstantDeclaration) semanticObject); 
				return; 
			case LimpPackage.CONTINUE_STATEMENT:
				sequence_Statement(context, (ContinueStatement) semanticObject); 
				return; 
			case LimpPackage.DEFINE:
				sequence_Define(context, (Define) semanticObject); 
				return; 
			case LimpPackage.DEFINE_USE_REF:
				sequence_DefineUseRef(context, (DefineUseRef) semanticObject); 
				return; 
			case LimpPackage.ELSE_BLOCK:
				sequence_Else(context, (ElseBlock) semanticObject); 
				return; 
			case LimpPackage.ELSE_IF:
				sequence_Else(context, (ElseIf) semanticObject); 
				return; 
			case LimpPackage.ENUM_TYPE:
				sequence_Type(context, (EnumType) semanticObject); 
				return; 
			case LimpPackage.ENUM_TYPE_DEF:
				sequence_EnumTypeDef(context, (EnumTypeDef) semanticObject); 
				return; 
			case LimpPackage.ENUM_VALUE:
				sequence_EnumValue(context, (EnumValue) semanticObject); 
				return; 
			case LimpPackage.EQUATION_BLOCK:
				sequence_EquationBlock(context, (EquationBlock) semanticObject); 
				return; 
			case LimpPackage.EXPR_LIST:
				sequence_ExprList(context, (ExprList) semanticObject); 
				return; 
			case LimpPackage.EXTERNAL_FUNCTION:
				sequence_ExternalFunction(context, (ExternalFunction) semanticObject); 
				return; 
			case LimpPackage.EXTERNAL_PROCEDURE:
				sequence_ExternalProcedure(context, (ExternalProcedure) semanticObject); 
				return; 
			case LimpPackage.FCN_CALL_EXPR:
				sequence_TerminalExpr(context, (FcnCallExpr) semanticObject); 
				return; 
			case LimpPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case LimpPackage.FRESH_VARIABLE:
				sequence_ExtendedExpr(context, (FreshVariable) semanticObject); 
				return; 
			case LimpPackage.GLOBAL_DECLARATION:
				sequence_GlobalDeclaration(context, (GlobalDeclaration) semanticObject); 
				return; 
			case LimpPackage.GOTO_STATEMENT:
				sequence_GotoStatement(context, (GotoStatement) semanticObject); 
				return; 
			case LimpPackage.ID_EXPR:
				sequence_TerminalExpr(context, (IdExpr) semanticObject); 
				return; 
			case LimpPackage.ID_LIST:
				sequence_IdList(context, (IdList) semanticObject); 
				return; 
			case LimpPackage.IF_THEN_ELSE_EXPR:
				sequence_IfThenElseExpr(context, (IfThenElseExpr) semanticObject); 
				return; 
			case LimpPackage.IF_THEN_ELSE_STATEMENT:
				sequence_IfThenElseStatement(context, (IfThenElseStatement) semanticObject); 
				return; 
			case LimpPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case LimpPackage.INIT_EXPR:
				sequence_TerminalExpr(context, (InitExpr) semanticObject); 
				return; 
			case LimpPackage.INPUT_ARG:
				sequence_InputArg(context, (InputArg) semanticObject); 
				return; 
			case LimpPackage.INPUT_ARG_LIST:
				sequence_InputArgList(context, (InputArgList) semanticObject); 
				return; 
			case LimpPackage.INTEGER_LITERAL_EXPR:
				sequence_TerminalExpr(context, (IntegerLiteralExpr) semanticObject); 
				return; 
			case LimpPackage.INTEGER_TYPE:
				sequence_Type(context, (IntegerType) semanticObject); 
				return; 
			case LimpPackage.INTEGER_WILD_CARD_EXPR:
				sequence_TerminalExpr(context, (IntegerWildCardExpr) semanticObject); 
				return; 
			case LimpPackage.LABEL_STATEMENT:
				sequence_LabelStatement(context, (LabelStatement) semanticObject); 
				return; 
			case LimpPackage.LOCAL_ARG:
				sequence_LocalArg(context, (LocalArg) semanticObject); 
				return; 
			case LimpPackage.LOCAL_FUNCTION:
				sequence_LocalFunction(context, (LocalFunction) semanticObject); 
				return; 
			case LimpPackage.LOCAL_PROCEDURE:
				sequence_LocalProcedure(context, (LocalProcedure) semanticObject); 
				return; 
			case LimpPackage.NAMED_TYPE:
				sequence_Type(context, (NamedType) semanticObject); 
				return; 
			case LimpPackage.NO_ATTRIBUTE_BLOCK:
				sequence_AttributeBlock(context, (NoAttributeBlock) semanticObject); 
				return; 
			case LimpPackage.NO_ELSE:
				sequence_Else(context, (NoElse) semanticObject); 
				return; 
			case LimpPackage.NO_VAR_BLOCK:
				sequence_VarBlock(context, (NoVarBlock) semanticObject); 
				return; 
			case LimpPackage.OUTPUT_ARG:
				sequence_OutputArg(context, (OutputArg) semanticObject); 
				return; 
			case LimpPackage.OUTPUT_ARG_LIST:
				sequence_OutputArgList(context, (OutputArgList) semanticObject); 
				return; 
			case LimpPackage.POSTCONDITION:
				sequence_Postcondition(context, (Postcondition) semanticObject); 
				return; 
			case LimpPackage.PRECONDITION:
				sequence_Precondition(context, (Precondition) semanticObject); 
				return; 
			case LimpPackage.REAL_LITERAL_EXPR:
				sequence_TerminalExpr(context, (RealLiteralExpr) semanticObject); 
				return; 
			case LimpPackage.REAL_TYPE:
				sequence_Type(context, (RealType) semanticObject); 
				return; 
			case LimpPackage.RECORD_ACCESS_EXPR:
				sequence_AccessExpr(context, (RecordAccessExpr) semanticObject); 
				return; 
			case LimpPackage.RECORD_EXPR:
				sequence_RecordExpr(context, (RecordExpr) semanticObject); 
				return; 
			case LimpPackage.RECORD_FIELD_EXPR:
				sequence_RecordFieldExpr(context, (RecordFieldExpr) semanticObject); 
				return; 
			case LimpPackage.RECORD_FIELD_TYPE:
				sequence_RecordFieldType(context, (RecordFieldType) semanticObject); 
				return; 
			case LimpPackage.RECORD_TYPE:
				sequence_Type(context, (RecordType) semanticObject); 
				return; 
			case LimpPackage.RECORD_TYPE_DEF:
				sequence_RecordTypeDef(context, (RecordTypeDef) semanticObject); 
				return; 
			case LimpPackage.RECORD_UPDATE_EXPR:
				sequence_AccessExpr(context, (RecordUpdateExpr) semanticObject); 
				return; 
			case LimpPackage.RETURN_STATEMENT:
				sequence_Statement(context, (ReturnStatement) semanticObject); 
				return; 
			case LimpPackage.SECOND_INIT:
				sequence_TerminalExpr(context, (SecondInit) semanticObject); 
				return; 
			case LimpPackage.SOME_ATTRIBUTE_BLOCK:
				sequence_AttributeBlock(context, (SomeAttributeBlock) semanticObject); 
				return; 
			case LimpPackage.SOME_VAR_BLOCK:
				sequence_VarBlock(context, (SomeVarBlock) semanticObject); 
				return; 
			case LimpPackage.SPECIFICATION:
				sequence_Specification(context, (Specification) semanticObject); 
				return; 
			case LimpPackage.STATEMENT_BLOCK:
				sequence_StatementBlock(context, (StatementBlock) semanticObject); 
				return; 
			case LimpPackage.STRING_LITERAL_EXPR:
				sequence_TerminalExpr(context, (StringLiteralExpr) semanticObject); 
				return; 
			case LimpPackage.STRING_TYPE:
				sequence_Type(context, (StringType) semanticObject); 
				return; 
			case LimpPackage.TUPLE_TYPE:
				sequence_ExtendedType(context, (TupleType) semanticObject); 
				return; 
			case LimpPackage.TYPE_ALIAS:
				sequence_TypeDeclaration(context, (TypeAlias) semanticObject); 
				return; 
			case LimpPackage.UNARY_MINUS_EXPR:
				sequence_UnaryExpr(context, (UnaryMinusExpr) semanticObject); 
				return; 
			case LimpPackage.UNARY_NEGATION_EXPR:
				sequence_UnaryExpr(context, (UnaryNegationExpr) semanticObject); 
				return; 
			case LimpPackage.USES:
				sequence_Uses(context, (Uses) semanticObject); 
				return; 
			case LimpPackage.VOID_STATEMENT:
				sequence_VoidStatement(context, (VoidStatement) semanticObject); 
				return; 
			case LimpPackage.VOID_TYPE:
				sequence_Type(context, (VoidType) semanticObject); 
				return; 
			case LimpPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Declaration returns AbstractTypeDef
	 *     TypeDeclaration returns AbstractTypeDef
	 *     AbstractTypeDef returns AbstractTypeDef
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_AbstractTypeDef(ISerializationContext context, AbstractTypeDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.TYPE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.TYPE_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbstractTypeDefAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns ArrayAccessExpr
	 *     IfThenElseExpr returns ArrayAccessExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns ArrayAccessExpr
	 *     ChoiceExpr returns ArrayAccessExpr
	 *     ImpliesExpr returns ArrayAccessExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns ArrayAccessExpr
	 *     OrExpr returns ArrayAccessExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns ArrayAccessExpr
	 *     AndExpr returns ArrayAccessExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns ArrayAccessExpr
	 *     RelationalExpr returns ArrayAccessExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns ArrayAccessExpr
	 *     PlusExpr returns ArrayAccessExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns ArrayAccessExpr
	 *     MultExpr returns ArrayAccessExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns ArrayAccessExpr
	 *     UnaryExpr returns ArrayAccessExpr
	 *     AccessExpr returns ArrayAccessExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns ArrayAccessExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns ArrayAccessExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns ArrayAccessExpr
	 *     AccessExpr.ArrayUpdateExpr_1_2_2_0_0_0 returns ArrayAccessExpr
	 *     TerminalExpr returns ArrayAccessExpr
	 *
	 * Constraint:
	 *     (array=AccessExpr_ArrayAccessExpr_1_2_0_0_0 index=Expr)
	 */
	protected void sequence_AccessExpr(ISerializationContext context, ArrayAccessExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.ARRAY_ACCESS_EXPR__ARRAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.ARRAY_ACCESS_EXPR__ARRAY));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.ARRAY_ACCESS_EXPR__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.ARRAY_ACCESS_EXPR__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAccessExprAccess().getArrayAccessExprArrayAction_1_2_0_0_0(), semanticObject.getArray());
		feeder.accept(grammarAccess.getAccessExprAccess().getIndexExprParserRuleCall_1_2_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns ArrayUpdateExpr
	 *     IfThenElseExpr returns ArrayUpdateExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns ArrayUpdateExpr
	 *     ChoiceExpr returns ArrayUpdateExpr
	 *     ImpliesExpr returns ArrayUpdateExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns ArrayUpdateExpr
	 *     OrExpr returns ArrayUpdateExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns ArrayUpdateExpr
	 *     AndExpr returns ArrayUpdateExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns ArrayUpdateExpr
	 *     RelationalExpr returns ArrayUpdateExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns ArrayUpdateExpr
	 *     PlusExpr returns ArrayUpdateExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns ArrayUpdateExpr
	 *     MultExpr returns ArrayUpdateExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns ArrayUpdateExpr
	 *     UnaryExpr returns ArrayUpdateExpr
	 *     AccessExpr returns ArrayUpdateExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns ArrayUpdateExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns ArrayUpdateExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns ArrayUpdateExpr
	 *     TerminalExpr returns ArrayUpdateExpr
	 *
	 * Constraint:
	 *     (access=AccessExpr_ArrayUpdateExpr_1_2_2_0_0_0 value=Expr)
	 */
	protected void sequence_AccessExpr(ISerializationContext context, ArrayUpdateExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.ARRAY_UPDATE_EXPR__ACCESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.ARRAY_UPDATE_EXPR__ACCESS));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.ARRAY_UPDATE_EXPR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.ARRAY_UPDATE_EXPR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAccessExprAccess().getArrayUpdateExprAccessAction_1_2_2_0_0_0(), semanticObject.getAccess());
		feeder.accept(grammarAccess.getAccessExprAccess().getValueExprParserRuleCall_1_2_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns RecordAccessExpr
	 *     IfThenElseExpr returns RecordAccessExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns RecordAccessExpr
	 *     ChoiceExpr returns RecordAccessExpr
	 *     ImpliesExpr returns RecordAccessExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns RecordAccessExpr
	 *     OrExpr returns RecordAccessExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns RecordAccessExpr
	 *     AndExpr returns RecordAccessExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns RecordAccessExpr
	 *     RelationalExpr returns RecordAccessExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns RecordAccessExpr
	 *     PlusExpr returns RecordAccessExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns RecordAccessExpr
	 *     MultExpr returns RecordAccessExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns RecordAccessExpr
	 *     UnaryExpr returns RecordAccessExpr
	 *     AccessExpr returns RecordAccessExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns RecordAccessExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns RecordAccessExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns RecordAccessExpr
	 *     TerminalExpr returns RecordAccessExpr
	 *
	 * Constraint:
	 *     (record=AccessExpr_RecordAccessExpr_1_0_0_0_0 field=ID)
	 */
	protected void sequence_AccessExpr(ISerializationContext context, RecordAccessExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.RECORD_ACCESS_EXPR__RECORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.RECORD_ACCESS_EXPR__RECORD));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.RECORD_ACCESS_EXPR__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.RECORD_ACCESS_EXPR__FIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAccessExprAccess().getRecordAccessExprRecordAction_1_0_0_0_0(), semanticObject.getRecord());
		feeder.accept(grammarAccess.getAccessExprAccess().getFieldIDTerminalRuleCall_1_0_1_0(), semanticObject.getField());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns RecordUpdateExpr
	 *     IfThenElseExpr returns RecordUpdateExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns RecordUpdateExpr
	 *     ChoiceExpr returns RecordUpdateExpr
	 *     ImpliesExpr returns RecordUpdateExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns RecordUpdateExpr
	 *     OrExpr returns RecordUpdateExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns RecordUpdateExpr
	 *     AndExpr returns RecordUpdateExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns RecordUpdateExpr
	 *     RelationalExpr returns RecordUpdateExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns RecordUpdateExpr
	 *     PlusExpr returns RecordUpdateExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns RecordUpdateExpr
	 *     MultExpr returns RecordUpdateExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns RecordUpdateExpr
	 *     UnaryExpr returns RecordUpdateExpr
	 *     AccessExpr returns RecordUpdateExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns RecordUpdateExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns RecordUpdateExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns RecordUpdateExpr
	 *     TerminalExpr returns RecordUpdateExpr
	 *
	 * Constraint:
	 *     (record=AccessExpr_RecordUpdateExpr_1_1_0_0_0 field=ID value=Expr)
	 */
	protected void sequence_AccessExpr(ISerializationContext context, RecordUpdateExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.RECORD_UPDATE_EXPR__RECORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.RECORD_UPDATE_EXPR__RECORD));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.RECORD_UPDATE_EXPR__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.RECORD_UPDATE_EXPR__FIELD));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.RECORD_UPDATE_EXPR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.RECORD_UPDATE_EXPR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAccessExprAccess().getRecordUpdateExprRecordAction_1_1_0_0_0(), semanticObject.getRecord());
		feeder.accept(grammarAccess.getAccessExprAccess().getFieldIDTerminalRuleCall_1_1_0_0_2_0(), semanticObject.getField());
		feeder.accept(grammarAccess.getAccessExprAccess().getValueExprParserRuleCall_1_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns BinaryExpr
	 *     IfThenElseExpr returns BinaryExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns BinaryExpr
	 *     ChoiceExpr returns BinaryExpr
	 *     ImpliesExpr returns BinaryExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     OrExpr returns BinaryExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     AndExpr returns BinaryExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     RelationalExpr returns BinaryExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     PlusExpr returns BinaryExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     MultExpr returns BinaryExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns BinaryExpr
	 *     UnaryExpr returns BinaryExpr
	 *     AccessExpr returns BinaryExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns BinaryExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns BinaryExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns BinaryExpr
	 *     TerminalExpr returns BinaryExpr
	 *
	 * Constraint:
	 *     (
	 *         (left=ImpliesExpr_BinaryExpr_1_0_0_0 op='=>' right=ImpliesExpr) | 
	 *         (left=OrExpr_BinaryExpr_1_0_0_0 op='or' right=AndExpr) | 
	 *         (left=AndExpr_BinaryExpr_1_0_0_0 op='and' right=RelationalExpr) | 
	 *         (left=RelationalExpr_BinaryExpr_1_0_0_0 op=RelationalOp right=PlusExpr) | 
	 *         (left=PlusExpr_BinaryExpr_1_0_0_0 (op='+' | op='-') right=MultExpr) | 
	 *         (left=MultExpr_BinaryExpr_1_0_0_0 (op='*' | op='/') right=UnaryExpr)
	 *     )
	 */
	protected void sequence_AndExpr_ImpliesExpr_MultExpr_OrExpr_PlusExpr_RelationalExpr(ISerializationContext context, BinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns ArrayExpr
	 *     IfThenElseExpr returns ArrayExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns ArrayExpr
	 *     ChoiceExpr returns ArrayExpr
	 *     ImpliesExpr returns ArrayExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns ArrayExpr
	 *     OrExpr returns ArrayExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns ArrayExpr
	 *     AndExpr returns ArrayExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns ArrayExpr
	 *     RelationalExpr returns ArrayExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns ArrayExpr
	 *     PlusExpr returns ArrayExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns ArrayExpr
	 *     MultExpr returns ArrayExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns ArrayExpr
	 *     UnaryExpr returns ArrayExpr
	 *     AccessExpr returns ArrayExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns ArrayExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns ArrayExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns ArrayExpr
	 *     TerminalExpr returns ArrayExpr
	 *     ArrayExpr returns ArrayExpr
	 *
	 * Constraint:
	 *     (arrayDefinition=[ArrayTypeDef|ID] exprList+=Expr exprList+=Expr*)
	 */
	protected void sequence_ArrayExpr(ISerializationContext context, ArrayExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns ArrayTypeDef
	 *     TypeDeclaration returns ArrayTypeDef
	 *     ArrayTypeDef returns ArrayTypeDef
	 *
	 * Constraint:
	 *     (name=ID baseType=Type size=INT)
	 */
	protected void sequence_ArrayTypeDef(ISerializationContext context, ArrayTypeDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.TYPE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.TYPE_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.ARRAY_TYPE_DEF__BASE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.ARRAY_TYPE_DEF__BASE_TYPE));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.ARRAY_TYPE_DEF__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.ARRAY_TYPE_DEF__SIZE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayTypeDefAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getArrayTypeDefAccess().getBaseTypeTypeParserRuleCall_4_0(), semanticObject.getBaseType());
		feeder.accept(grammarAccess.getArrayTypeDefAccess().getSizeINTTerminalRuleCall_6_0(), semanticObject.getSize());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AssignmentStatement
	 *     AssignmentStatement returns AssignmentStatement
	 *     Equation returns AssignmentStatement
	 *
	 * Constraint:
	 *     (ids=IdList rhs=Expr)
	 */
	protected void sequence_AssignmentStatement(ISerializationContext context, AssignmentStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.ASSIGNMENT_STATEMENT__IDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.ASSIGNMENT_STATEMENT__IDS));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.ASSIGNMENT_STATEMENT__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.ASSIGNMENT_STATEMENT__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentStatementAccess().getIdsIdListParserRuleCall_0_0(), semanticObject.getIds());
		feeder.accept(grammarAccess.getAssignmentStatementAccess().getRhsExprParserRuleCall_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeBlock returns NoAttributeBlock
	 *
	 * Constraint:
	 *     {NoAttributeBlock}
	 */
	protected void sequence_AttributeBlock(ISerializationContext context, NoAttributeBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeBlock returns SomeAttributeBlock
	 *
	 * Constraint:
	 *     attributeList+=Attribute*
	 */
	protected void sequence_AttributeBlock(ISerializationContext context, SomeAttributeBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns ChoiceExpr
	 *     IfThenElseExpr returns ChoiceExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns ChoiceExpr
	 *     ChoiceExpr returns ChoiceExpr
	 *     ImpliesExpr returns ChoiceExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns ChoiceExpr
	 *     OrExpr returns ChoiceExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns ChoiceExpr
	 *     AndExpr returns ChoiceExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns ChoiceExpr
	 *     RelationalExpr returns ChoiceExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns ChoiceExpr
	 *     PlusExpr returns ChoiceExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns ChoiceExpr
	 *     MultExpr returns ChoiceExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns ChoiceExpr
	 *     UnaryExpr returns ChoiceExpr
	 *     AccessExpr returns ChoiceExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns ChoiceExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns ChoiceExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns ChoiceExpr
	 *     TerminalExpr returns ChoiceExpr
	 *
	 * Constraint:
	 *     (first=Expr second=Expr)
	 */
	protected void sequence_ChoiceExpr(ISerializationContext context, ChoiceExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.CHOICE_EXPR__FIRST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.CHOICE_EXPR__FIRST));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.CHOICE_EXPR__SECOND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.CHOICE_EXPR__SECOND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChoiceExprAccess().getFirstExprParserRuleCall_0_3_0(), semanticObject.getFirst());
		feeder.accept(grammarAccess.getChoiceExprAccess().getSecondExprParserRuleCall_0_5_0(), semanticObject.getSecond());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Comment
	 *     Comment returns Comment
	 *
	 * Constraint:
	 *     comment=SEMANTIC_COMMENT
	 */
	protected void sequence_Comment(ISerializationContext context, Comment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.COMMENT__COMMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.COMMENT__COMMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommentAccess().getCommentSEMANTIC_COMMENTTerminalRuleCall_0(), semanticObject.getComment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns ConstantDeclaration
	 *     ConstantDeclaration returns ConstantDeclaration
	 *     VariableRef returns ConstantDeclaration
	 *
	 * Constraint:
	 *     (name=ID type=Type expr=Expr?)
	 */
	protected void sequence_ConstantDeclaration(ISerializationContext context, ConstantDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefineUseRef returns DefineUseRef
	 *
	 * Constraint:
	 *     referenceExpr=Expr
	 */
	protected void sequence_DefineUseRef(ISerializationContext context, DefineUseRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.DEFINE_USE_REF__REFERENCE_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.DEFINE_USE_REF__REFERENCE_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefineUseRefAccess().getReferenceExprExprParserRuleCall_0(), semanticObject.getReferenceExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Define
	 *     Define returns Define
	 *
	 * Constraint:
	 *     (elements+=DefineUseRef elements+=DefineUseRef*)
	 */
	protected void sequence_Define(ISerializationContext context, Define semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Else returns ElseBlock
	 *
	 * Constraint:
	 *     block=StatementBlock
	 */
	protected void sequence_Else(ISerializationContext context, ElseBlock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.ELSE_BLOCK__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.ELSE_BLOCK__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElseAccess().getBlockStatementBlockParserRuleCall_0_2_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Else returns ElseIf
	 *
	 * Constraint:
	 *     ifThenElse=IfThenElseStatement
	 */
	protected void sequence_Else(ISerializationContext context, ElseIf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.ELSE_IF__IF_THEN_ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.ELSE_IF__IF_THEN_ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElseAccess().getIfThenElseIfThenElseStatementParserRuleCall_1_2_0(), semanticObject.getIfThenElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Else returns NoElse
	 *
	 * Constraint:
	 *     {NoElse}
	 */
	protected void sequence_Else(ISerializationContext context, NoElse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns EnumTypeDef
	 *     TypeDeclaration returns EnumTypeDef
	 *     EnumTypeDef returns EnumTypeDef
	 *
	 * Constraint:
	 *     (name=ID enumerations+=EnumValue enumerations+=EnumValue*)
	 */
	protected void sequence_EnumTypeDef(ISerializationContext context, EnumTypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumValue returns EnumValue
	 *     VariableRef returns EnumValue
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnumValue(ISerializationContext context, EnumValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.VARIABLE_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.VARIABLE_REF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumValueAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EquationBlock returns EquationBlock
	 *
	 * Constraint:
	 *     equations+=Equation*
	 */
	protected void sequence_EquationBlock(ISerializationContext context, EquationBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprList returns ExprList
	 *
	 * Constraint:
	 *     (exprList+=Expr exprList+=Expr*)?
	 */
	protected void sequence_ExprList(ISerializationContext context, ExprList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExtendedExpr returns FreshVariable
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_ExtendedExpr(ISerializationContext context, FreshVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.FRESH_VARIABLE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.FRESH_VARIABLE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtendedExprAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExtendedType returns TupleType
	 *
	 * Constraint:
	 *     (typeList+=Type typeList+=Type*)
	 */
	protected void sequence_ExtendedType(ISerializationContext context, TupleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns ExternalFunction
	 *     ExternalFunction returns ExternalFunction
	 *     FunctionRef returns ExternalFunction
	 *
	 * Constraint:
	 *     (name=ID inputs=InputArgList output=OutputArg)
	 */
	protected void sequence_ExternalFunction(ISerializationContext context, ExternalFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.EXTERNAL_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.EXTERNAL_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.EXTERNAL_FUNCTION__INPUTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.EXTERNAL_FUNCTION__INPUTS));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.EXTERNAL_FUNCTION__OUTPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.EXTERNAL_FUNCTION__OUTPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternalFunctionAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExternalFunctionAccess().getInputsInputArgListParserRuleCall_4_0(), semanticObject.getInputs());
		feeder.accept(grammarAccess.getExternalFunctionAccess().getOutputOutputArgParserRuleCall_8_0(), semanticObject.getOutput());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns ExternalProcedure
	 *     ExternalProcedure returns ExternalProcedure
	 *     FunctionRef returns ExternalProcedure
	 *
	 * Constraint:
	 *     (name=ID inputs=InputArgList outputs=OutputArgList attributeBlock=AttributeBlock)
	 */
	protected void sequence_ExternalProcedure(ISerializationContext context, ExternalProcedure semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.EXTERNAL_PROCEDURE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.EXTERNAL_PROCEDURE__NAME));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.EXTERNAL_PROCEDURE__INPUTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.EXTERNAL_PROCEDURE__INPUTS));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.EXTERNAL_PROCEDURE__OUTPUTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.EXTERNAL_PROCEDURE__OUTPUTS));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.EXTERNAL_PROCEDURE__ATTRIBUTE_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.EXTERNAL_PROCEDURE__ATTRIBUTE_BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternalProcedureAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExternalProcedureAccess().getInputsInputArgListParserRuleCall_4_0(), semanticObject.getInputs());
		feeder.accept(grammarAccess.getExternalProcedureAccess().getOutputsOutputArgListParserRuleCall_8_0(), semanticObject.getOutputs());
		feeder.accept(grammarAccess.getExternalProcedureAccess().getAttributeBlockAttributeBlockParserRuleCall_10_0(), semanticObject.getAttributeBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (initStatement=AssignmentStatement limitExpr=Expr incrementStatement=AssignmentStatement block=StatementBlock)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.FOR_STATEMENT__INIT_STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.FOR_STATEMENT__INIT_STATEMENT));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.FOR_STATEMENT__LIMIT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.FOR_STATEMENT__LIMIT_EXPR));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.FOR_STATEMENT__INCREMENT_STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.FOR_STATEMENT__INCREMENT_STATEMENT));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.FOR_STATEMENT__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.FOR_STATEMENT__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForStatementAccess().getInitStatementAssignmentStatementParserRuleCall_2_0(), semanticObject.getInitStatement());
		feeder.accept(grammarAccess.getForStatementAccess().getLimitExprExprParserRuleCall_3_0(), semanticObject.getLimitExpr());
		feeder.accept(grammarAccess.getForStatementAccess().getIncrementStatementAssignmentStatementParserRuleCall_5_0(), semanticObject.getIncrementStatement());
		feeder.accept(grammarAccess.getForStatementAccess().getBlockStatementBlockParserRuleCall_7_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns GlobalDeclaration
	 *     GlobalDeclaration returns GlobalDeclaration
	 *     VariableRef returns GlobalDeclaration
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_GlobalDeclaration(ISerializationContext context, GlobalDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.VARIABLE_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.VARIABLE_REF__NAME));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.GLOBAL_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.GLOBAL_DECLARATION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGlobalDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getGlobalDeclarationAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GotoStatement
	 *     GotoStatement returns GotoStatement
	 *
	 * Constraint:
	 *     (label=[LabelStatement|ID] whenExpr=Expr?)
	 */
	protected void sequence_GotoStatement(ISerializationContext context, GotoStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IdList returns IdList
	 *
	 * Constraint:
	 *     (ids+=[VariableRef|ID] ids+=[VariableRef|ID]*)
	 */
	protected void sequence_IdList(ISerializationContext context, IdList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns IfThenElseExpr
	 *     IfThenElseExpr returns IfThenElseExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns IfThenElseExpr
	 *     ChoiceExpr returns IfThenElseExpr
	 *     ImpliesExpr returns IfThenElseExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     OrExpr returns IfThenElseExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     AndExpr returns IfThenElseExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     RelationalExpr returns IfThenElseExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     PlusExpr returns IfThenElseExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     MultExpr returns IfThenElseExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns IfThenElseExpr
	 *     UnaryExpr returns IfThenElseExpr
	 *     AccessExpr returns IfThenElseExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns IfThenElseExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns IfThenElseExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns IfThenElseExpr
	 *     TerminalExpr returns IfThenElseExpr
	 *
	 * Constraint:
	 *     (condExpr=IfThenElseExpr_IfThenElseExpr_1_0_0_0 thenExpr=Expr elseExpr=Expr)
	 */
	protected void sequence_IfThenElseExpr(ISerializationContext context, IfThenElseExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.IF_THEN_ELSE_EXPR__COND_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.IF_THEN_ELSE_EXPR__COND_EXPR));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.IF_THEN_ELSE_EXPR__THEN_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.IF_THEN_ELSE_EXPR__THEN_EXPR));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.IF_THEN_ELSE_EXPR__ELSE_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.IF_THEN_ELSE_EXPR__ELSE_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfThenElseExprAccess().getIfThenElseExprCondExprAction_1_0_0_0(), semanticObject.getCondExpr());
		feeder.accept(grammarAccess.getIfThenElseExprAccess().getThenExprExprParserRuleCall_1_1_0(), semanticObject.getThenExpr());
		feeder.accept(grammarAccess.getIfThenElseExprAccess().getElseExprExprParserRuleCall_1_3_0(), semanticObject.getElseExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfThenElseStatement
	 *     IfThenElseStatement returns IfThenElseStatement
	 *
	 * Constraint:
	 *     (cond=Expr thenBlock=StatementBlock else=Else)
	 */
	protected void sequence_IfThenElseStatement(ISerializationContext context, IfThenElseStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.IF_THEN_ELSE_STATEMENT__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.IF_THEN_ELSE_STATEMENT__COND));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.IF_THEN_ELSE_STATEMENT__THEN_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.IF_THEN_ELSE_STATEMENT__THEN_BLOCK));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.IF_THEN_ELSE_STATEMENT__ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.IF_THEN_ELSE_STATEMENT__ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfThenElseStatementAccess().getCondExprParserRuleCall_1_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getIfThenElseStatementAccess().getThenBlockStatementBlockParserRuleCall_3_0(), semanticObject.getThenBlock());
		feeder.accept(grammarAccess.getIfThenElseStatementAccess().getElseElseParserRuleCall_4_0(), semanticObject.getElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Import
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.IMPORT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputArgList returns InputArgList
	 *
	 * Constraint:
	 *     (inputArgs+=InputArg inputArgs+=InputArg*)?
	 */
	protected void sequence_InputArgList(ISerializationContext context, InputArgList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableRef returns InputArg
	 *     InputArg returns InputArg
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_InputArg(ISerializationContext context, InputArg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.VARIABLE_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.VARIABLE_REF__NAME));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.INPUT_ARG__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.INPUT_ARG__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputArgAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInputArgAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LabelStatement
	 *     LabelStatement returns LabelStatement
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_LabelStatement(ISerializationContext context, LabelStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.LABEL_STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.LABEL_STATEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelStatementAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableRef returns LocalArg
	 *     LocalArg returns LocalArg
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_LocalArg(ISerializationContext context, LocalArg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.VARIABLE_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.VARIABLE_REF__NAME));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.LOCAL_ARG__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.LOCAL_ARG__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalArgAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLocalArgAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns LocalFunction
	 *     LocalFunction returns LocalFunction
	 *     FunctionRef returns LocalFunction
	 *
	 * Constraint:
	 *     (name=ID inputs=InputArgList output=OutputArg varBlock=VarBlock equationBlock=EquationBlock)
	 */
	protected void sequence_LocalFunction(ISerializationContext context, LocalFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.LOCAL_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.LOCAL_FUNCTION__NAME));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.LOCAL_FUNCTION__INPUTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.LOCAL_FUNCTION__INPUTS));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.LOCAL_FUNCTION__OUTPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.LOCAL_FUNCTION__OUTPUT));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.LOCAL_FUNCTION__VAR_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.LOCAL_FUNCTION__VAR_BLOCK));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.LOCAL_FUNCTION__EQUATION_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.LOCAL_FUNCTION__EQUATION_BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalFunctionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLocalFunctionAccess().getInputsInputArgListParserRuleCall_3_0(), semanticObject.getInputs());
		feeder.accept(grammarAccess.getLocalFunctionAccess().getOutputOutputArgParserRuleCall_7_0(), semanticObject.getOutput());
		feeder.accept(grammarAccess.getLocalFunctionAccess().getVarBlockVarBlockParserRuleCall_9_0(), semanticObject.getVarBlock());
		feeder.accept(grammarAccess.getLocalFunctionAccess().getEquationBlockEquationBlockParserRuleCall_11_0(), semanticObject.getEquationBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns LocalProcedure
	 *     LocalProcedure returns LocalProcedure
	 *     FunctionRef returns LocalProcedure
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         inputs=InputArgList 
	 *         outputs=OutputArgList 
	 *         varBlock=VarBlock 
	 *         attributeBlock=AttributeBlock 
	 *         statementblock=StatementBlock
	 *     )
	 */
	protected void sequence_LocalProcedure(ISerializationContext context, LocalProcedure semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.LOCAL_PROCEDURE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.LOCAL_PROCEDURE__NAME));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.LOCAL_PROCEDURE__INPUTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.LOCAL_PROCEDURE__INPUTS));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.LOCAL_PROCEDURE__OUTPUTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.LOCAL_PROCEDURE__OUTPUTS));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.LOCAL_PROCEDURE__VAR_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.LOCAL_PROCEDURE__VAR_BLOCK));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.LOCAL_PROCEDURE__ATTRIBUTE_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.LOCAL_PROCEDURE__ATTRIBUTE_BLOCK));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.LOCAL_PROCEDURE__STATEMENTBLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.LOCAL_PROCEDURE__STATEMENTBLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalProcedureAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLocalProcedureAccess().getInputsInputArgListParserRuleCall_3_0(), semanticObject.getInputs());
		feeder.accept(grammarAccess.getLocalProcedureAccess().getOutputsOutputArgListParserRuleCall_7_0(), semanticObject.getOutputs());
		feeder.accept(grammarAccess.getLocalProcedureAccess().getVarBlockVarBlockParserRuleCall_9_0(), semanticObject.getVarBlock());
		feeder.accept(grammarAccess.getLocalProcedureAccess().getAttributeBlockAttributeBlockParserRuleCall_10_0(), semanticObject.getAttributeBlock());
		feeder.accept(grammarAccess.getLocalProcedureAccess().getStatementblockStatementBlockParserRuleCall_12_0(), semanticObject.getStatementblock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutputArgList returns OutputArgList
	 *
	 * Constraint:
	 *     (outputArgs+=OutputArg outputArgs+=OutputArg*)?
	 */
	protected void sequence_OutputArgList(ISerializationContext context, OutputArgList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableRef returns OutputArg
	 *     OutputArg returns OutputArg
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_OutputArg(ISerializationContext context, OutputArg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.VARIABLE_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.VARIABLE_REF__NAME));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.OUTPUT_ARG__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.OUTPUT_ARG__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutputArgAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOutputArgAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Postcondition
	 *     Postcondition returns Postcondition
	 *
	 * Constraint:
	 *     (name=ID expr=Expr)
	 */
	protected void sequence_Postcondition(ISerializationContext context, Postcondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.POSTCONDITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.POSTCONDITION__NAME));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.POSTCONDITION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.POSTCONDITION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostconditionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPostconditionAccess().getExprExprParserRuleCall_3_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Precondition
	 *     Precondition returns Precondition
	 *
	 * Constraint:
	 *     (name=ID expr=Expr)
	 */
	protected void sequence_Precondition(ISerializationContext context, Precondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.PRECONDITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.PRECONDITION__NAME));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.PRECONDITION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.PRECONDITION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreconditionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPreconditionAccess().getExprExprParserRuleCall_3_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns RecordExpr
	 *     IfThenElseExpr returns RecordExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns RecordExpr
	 *     ChoiceExpr returns RecordExpr
	 *     ImpliesExpr returns RecordExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns RecordExpr
	 *     OrExpr returns RecordExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns RecordExpr
	 *     AndExpr returns RecordExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns RecordExpr
	 *     RelationalExpr returns RecordExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns RecordExpr
	 *     PlusExpr returns RecordExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns RecordExpr
	 *     MultExpr returns RecordExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns RecordExpr
	 *     UnaryExpr returns RecordExpr
	 *     AccessExpr returns RecordExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns RecordExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns RecordExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns RecordExpr
	 *     TerminalExpr returns RecordExpr
	 *     RecordExpr returns RecordExpr
	 *
	 * Constraint:
	 *     (recordDefinition=[RecordTypeDef|ID] fieldExprList+=RecordFieldExpr fieldExprList+=RecordFieldExpr*)
	 */
	protected void sequence_RecordExpr(ISerializationContext context, RecordExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RecordFieldExpr returns RecordFieldExpr
	 *
	 * Constraint:
	 *     (fieldName=ID fieldExpr=Expr)
	 */
	protected void sequence_RecordFieldExpr(ISerializationContext context, RecordFieldExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.RECORD_FIELD_EXPR__FIELD_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.RECORD_FIELD_EXPR__FIELD_NAME));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.RECORD_FIELD_EXPR__FIELD_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.RECORD_FIELD_EXPR__FIELD_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecordFieldExprAccess().getFieldNameIDTerminalRuleCall_0_0(), semanticObject.getFieldName());
		feeder.accept(grammarAccess.getRecordFieldExprAccess().getFieldExprExprParserRuleCall_2_0(), semanticObject.getFieldExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RecordFieldType returns RecordFieldType
	 *
	 * Constraint:
	 *     (fieldName=ID fieldType=Type)
	 */
	protected void sequence_RecordFieldType(ISerializationContext context, RecordFieldType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.RECORD_FIELD_TYPE__FIELD_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.RECORD_FIELD_TYPE__FIELD_NAME));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.RECORD_FIELD_TYPE__FIELD_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.RECORD_FIELD_TYPE__FIELD_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecordFieldTypeAccess().getFieldNameIDTerminalRuleCall_0_0(), semanticObject.getFieldName());
		feeder.accept(grammarAccess.getRecordFieldTypeAccess().getFieldTypeTypeParserRuleCall_2_0(), semanticObject.getFieldType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns RecordTypeDef
	 *     TypeDeclaration returns RecordTypeDef
	 *     RecordTypeDef returns RecordTypeDef
	 *
	 * Constraint:
	 *     (name=ID fields+=RecordFieldType fields+=RecordFieldType*)
	 */
	protected void sequence_RecordTypeDef(ISerializationContext context, RecordTypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Specification returns Specification
	 *
	 * Constraint:
	 *     declarations+=Declaration+
	 */
	protected void sequence_Specification(ISerializationContext context, Specification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementBlock returns StatementBlock
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_StatementBlock(ISerializationContext context, StatementBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BreakStatement
	 *
	 * Constraint:
	 *     {BreakStatement}
	 */
	protected void sequence_Statement(ISerializationContext context, BreakStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ContinueStatement
	 *
	 * Constraint:
	 *     {ContinueStatement}
	 */
	protected void sequence_Statement(ISerializationContext context, ContinueStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *
	 * Constraint:
	 *     {ReturnStatement}
	 */
	protected void sequence_Statement(ISerializationContext context, ReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns BooleanLiteralExpr
	 *     IfThenElseExpr returns BooleanLiteralExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns BooleanLiteralExpr
	 *     ChoiceExpr returns BooleanLiteralExpr
	 *     ImpliesExpr returns BooleanLiteralExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns BooleanLiteralExpr
	 *     OrExpr returns BooleanLiteralExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns BooleanLiteralExpr
	 *     AndExpr returns BooleanLiteralExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns BooleanLiteralExpr
	 *     RelationalExpr returns BooleanLiteralExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns BooleanLiteralExpr
	 *     PlusExpr returns BooleanLiteralExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns BooleanLiteralExpr
	 *     MultExpr returns BooleanLiteralExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns BooleanLiteralExpr
	 *     UnaryExpr returns BooleanLiteralExpr
	 *     AccessExpr returns BooleanLiteralExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns BooleanLiteralExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns BooleanLiteralExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns BooleanLiteralExpr
	 *     TerminalExpr returns BooleanLiteralExpr
	 *
	 * Constraint:
	 *     boolVal=BOOLEAN
	 */
	protected void sequence_TerminalExpr(ISerializationContext context, BooleanLiteralExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.BOOLEAN_LITERAL_EXPR__BOOL_VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.BOOLEAN_LITERAL_EXPR__BOOL_VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExprAccess().getBoolValBOOLEANTerminalRuleCall_1_1_0(), semanticObject.getBoolVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns FcnCallExpr
	 *     IfThenElseExpr returns FcnCallExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns FcnCallExpr
	 *     ChoiceExpr returns FcnCallExpr
	 *     ImpliesExpr returns FcnCallExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns FcnCallExpr
	 *     OrExpr returns FcnCallExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns FcnCallExpr
	 *     AndExpr returns FcnCallExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns FcnCallExpr
	 *     RelationalExpr returns FcnCallExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns FcnCallExpr
	 *     PlusExpr returns FcnCallExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns FcnCallExpr
	 *     MultExpr returns FcnCallExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns FcnCallExpr
	 *     UnaryExpr returns FcnCallExpr
	 *     AccessExpr returns FcnCallExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns FcnCallExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns FcnCallExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns FcnCallExpr
	 *     TerminalExpr returns FcnCallExpr
	 *
	 * Constraint:
	 *     (id=[FunctionRef|ID] exprs=ExprList)
	 */
	protected void sequence_TerminalExpr(ISerializationContext context, FcnCallExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.FCN_CALL_EXPR__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.FCN_CALL_EXPR__ID));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.FCN_CALL_EXPR__EXPRS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.FCN_CALL_EXPR__EXPRS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExprAccess().getIdFunctionRefIDTerminalRuleCall_11_1_0_1(), semanticObject.getId());
		feeder.accept(grammarAccess.getTerminalExprAccess().getExprsExprListParserRuleCall_11_3_0(), semanticObject.getExprs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns IdExpr
	 *     IfThenElseExpr returns IdExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns IdExpr
	 *     ChoiceExpr returns IdExpr
	 *     ImpliesExpr returns IdExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     OrExpr returns IdExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     AndExpr returns IdExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     RelationalExpr returns IdExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     PlusExpr returns IdExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     MultExpr returns IdExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns IdExpr
	 *     UnaryExpr returns IdExpr
	 *     AccessExpr returns IdExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns IdExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns IdExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns IdExpr
	 *     TerminalExpr returns IdExpr
	 *
	 * Constraint:
	 *     id=[VariableRef|ID]
	 */
	protected void sequence_TerminalExpr(ISerializationContext context, IdExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.ID_EXPR__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.ID_EXPR__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExprAccess().getIdVariableRefIDTerminalRuleCall_10_1_0_1(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns InitExpr
	 *     IfThenElseExpr returns InitExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns InitExpr
	 *     ChoiceExpr returns InitExpr
	 *     ImpliesExpr returns InitExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns InitExpr
	 *     OrExpr returns InitExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns InitExpr
	 *     AndExpr returns InitExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns InitExpr
	 *     RelationalExpr returns InitExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns InitExpr
	 *     PlusExpr returns InitExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns InitExpr
	 *     MultExpr returns InitExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns InitExpr
	 *     UnaryExpr returns InitExpr
	 *     AccessExpr returns InitExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns InitExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns InitExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns InitExpr
	 *     TerminalExpr returns InitExpr
	 *
	 * Constraint:
	 *     id=[VariableRef|ID]
	 */
	protected void sequence_TerminalExpr(ISerializationContext context, InitExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.INIT_EXPR__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.INIT_EXPR__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExprAccess().getIdVariableRefIDTerminalRuleCall_6_2_0_1(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns IntegerLiteralExpr
	 *     IfThenElseExpr returns IntegerLiteralExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns IntegerLiteralExpr
	 *     ChoiceExpr returns IntegerLiteralExpr
	 *     ImpliesExpr returns IntegerLiteralExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns IntegerLiteralExpr
	 *     OrExpr returns IntegerLiteralExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns IntegerLiteralExpr
	 *     AndExpr returns IntegerLiteralExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns IntegerLiteralExpr
	 *     RelationalExpr returns IntegerLiteralExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns IntegerLiteralExpr
	 *     PlusExpr returns IntegerLiteralExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns IntegerLiteralExpr
	 *     MultExpr returns IntegerLiteralExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns IntegerLiteralExpr
	 *     UnaryExpr returns IntegerLiteralExpr
	 *     AccessExpr returns IntegerLiteralExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns IntegerLiteralExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns IntegerLiteralExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns IntegerLiteralExpr
	 *     TerminalExpr returns IntegerLiteralExpr
	 *
	 * Constraint:
	 *     intVal=INT
	 */
	protected void sequence_TerminalExpr(ISerializationContext context, IntegerLiteralExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.INTEGER_LITERAL_EXPR__INT_VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.INTEGER_LITERAL_EXPR__INT_VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExprAccess().getIntValINTTerminalRuleCall_2_1_0(), semanticObject.getIntVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns IntegerWildCardExpr
	 *     IfThenElseExpr returns IntegerWildCardExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns IntegerWildCardExpr
	 *     ChoiceExpr returns IntegerWildCardExpr
	 *     ImpliesExpr returns IntegerWildCardExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns IntegerWildCardExpr
	 *     OrExpr returns IntegerWildCardExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns IntegerWildCardExpr
	 *     AndExpr returns IntegerWildCardExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns IntegerWildCardExpr
	 *     RelationalExpr returns IntegerWildCardExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns IntegerWildCardExpr
	 *     PlusExpr returns IntegerWildCardExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns IntegerWildCardExpr
	 *     MultExpr returns IntegerWildCardExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns IntegerWildCardExpr
	 *     UnaryExpr returns IntegerWildCardExpr
	 *     AccessExpr returns IntegerWildCardExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns IntegerWildCardExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns IntegerWildCardExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns IntegerWildCardExpr
	 *     TerminalExpr returns IntegerWildCardExpr
	 *
	 * Constraint:
	 *     {IntegerWildCardExpr}
	 */
	protected void sequence_TerminalExpr(ISerializationContext context, IntegerWildCardExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns RealLiteralExpr
	 *     IfThenElseExpr returns RealLiteralExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns RealLiteralExpr
	 *     ChoiceExpr returns RealLiteralExpr
	 *     ImpliesExpr returns RealLiteralExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns RealLiteralExpr
	 *     OrExpr returns RealLiteralExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns RealLiteralExpr
	 *     AndExpr returns RealLiteralExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns RealLiteralExpr
	 *     RelationalExpr returns RealLiteralExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns RealLiteralExpr
	 *     PlusExpr returns RealLiteralExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns RealLiteralExpr
	 *     MultExpr returns RealLiteralExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns RealLiteralExpr
	 *     UnaryExpr returns RealLiteralExpr
	 *     AccessExpr returns RealLiteralExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns RealLiteralExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns RealLiteralExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns RealLiteralExpr
	 *     TerminalExpr returns RealLiteralExpr
	 *
	 * Constraint:
	 *     realVal=REAL
	 */
	protected void sequence_TerminalExpr(ISerializationContext context, RealLiteralExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.REAL_LITERAL_EXPR__REAL_VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.REAL_LITERAL_EXPR__REAL_VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExprAccess().getRealValREALTerminalRuleCall_4_1_0(), semanticObject.getRealVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns SecondInit
	 *     IfThenElseExpr returns SecondInit
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns SecondInit
	 *     ChoiceExpr returns SecondInit
	 *     ImpliesExpr returns SecondInit
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns SecondInit
	 *     OrExpr returns SecondInit
	 *     OrExpr.BinaryExpr_1_0_0_0 returns SecondInit
	 *     AndExpr returns SecondInit
	 *     AndExpr.BinaryExpr_1_0_0_0 returns SecondInit
	 *     RelationalExpr returns SecondInit
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns SecondInit
	 *     PlusExpr returns SecondInit
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns SecondInit
	 *     MultExpr returns SecondInit
	 *     MultExpr.BinaryExpr_1_0_0_0 returns SecondInit
	 *     UnaryExpr returns SecondInit
	 *     AccessExpr returns SecondInit
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns SecondInit
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns SecondInit
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns SecondInit
	 *     TerminalExpr returns SecondInit
	 *
	 * Constraint:
	 *     id=[VariableRef|ID]
	 */
	protected void sequence_TerminalExpr(ISerializationContext context, SecondInit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.SECOND_INIT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.SECOND_INIT__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExprAccess().getIdVariableRefIDTerminalRuleCall_7_2_0_1(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns StringLiteralExpr
	 *     IfThenElseExpr returns StringLiteralExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns StringLiteralExpr
	 *     ChoiceExpr returns StringLiteralExpr
	 *     ImpliesExpr returns StringLiteralExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns StringLiteralExpr
	 *     OrExpr returns StringLiteralExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns StringLiteralExpr
	 *     AndExpr returns StringLiteralExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns StringLiteralExpr
	 *     RelationalExpr returns StringLiteralExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns StringLiteralExpr
	 *     PlusExpr returns StringLiteralExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns StringLiteralExpr
	 *     MultExpr returns StringLiteralExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns StringLiteralExpr
	 *     UnaryExpr returns StringLiteralExpr
	 *     AccessExpr returns StringLiteralExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns StringLiteralExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns StringLiteralExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns StringLiteralExpr
	 *     TerminalExpr returns StringLiteralExpr
	 *
	 * Constraint:
	 *     stringVal=STRING
	 */
	protected void sequence_TerminalExpr(ISerializationContext context, StringLiteralExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.STRING_LITERAL_EXPR__STRING_VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.STRING_LITERAL_EXPR__STRING_VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExprAccess().getStringValSTRINGTerminalRuleCall_5_1_0(), semanticObject.getStringVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns TypeAlias
	 *     TypeDeclaration returns TypeAlias
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_TypeDeclaration(ISerializationContext context, TypeAlias semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.TYPE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.TYPE_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.TYPE_ALIAS__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.TYPE_ALIAS__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeDeclarationAccess().getNameIDTerminalRuleCall_0_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTypeDeclarationAccess().getTypeTypeParserRuleCall_0_4_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns AbstractType
	 *
	 * Constraint:
	 *     abstractDef=[AbstractTypeDef|ID]
	 */
	protected void sequence_Type(ISerializationContext context, AbstractType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.ABSTRACT_TYPE__ABSTRACT_DEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.ABSTRACT_TYPE__ABSTRACT_DEF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getAbstractDefAbstractTypeDefIDTerminalRuleCall_8_2_0_1(), semanticObject.getAbstractDef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ArrayType
	 *
	 * Constraint:
	 *     arrayDef=[ArrayTypeDef|ID]
	 */
	protected void sequence_Type(ISerializationContext context, ArrayType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.ARRAY_TYPE__ARRAY_DEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.ARRAY_TYPE__ARRAY_DEF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getArrayDefArrayTypeDefIDTerminalRuleCall_7_2_0_1(), semanticObject.getArrayDef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns BoolType
	 *
	 * Constraint:
	 *     {BoolType}
	 */
	protected void sequence_Type(ISerializationContext context, BoolType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns EnumType
	 *
	 * Constraint:
	 *     enumDef=[EnumTypeDef|ID]
	 */
	protected void sequence_Type(ISerializationContext context, EnumType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.ENUM_TYPE__ENUM_DEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.ENUM_TYPE__ENUM_DEF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getEnumDefEnumTypeDefIDTerminalRuleCall_5_2_0_1(), semanticObject.getEnumDef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns IntegerType
	 *
	 * Constraint:
	 *     {IntegerType}
	 */
	protected void sequence_Type(ISerializationContext context, IntegerType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns NamedType
	 *
	 * Constraint:
	 *     alias=[TypeAlias|ID]
	 */
	protected void sequence_Type(ISerializationContext context, NamedType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.NAMED_TYPE__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.NAMED_TYPE__ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getAliasTypeAliasIDTerminalRuleCall_9_1_0_1(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns RealType
	 *
	 * Constraint:
	 *     {RealType}
	 */
	protected void sequence_Type(ISerializationContext context, RealType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns RecordType
	 *
	 * Constraint:
	 *     recordDef=[RecordTypeDef|ID]
	 */
	protected void sequence_Type(ISerializationContext context, RecordType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.RECORD_TYPE__RECORD_DEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.RECORD_TYPE__RECORD_DEF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getRecordDefRecordTypeDefIDTerminalRuleCall_6_2_0_1(), semanticObject.getRecordDef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns StringType
	 *
	 * Constraint:
	 *     {StringType}
	 */
	protected void sequence_Type(ISerializationContext context, StringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns VoidType
	 *
	 * Constraint:
	 *     {VoidType}
	 */
	protected void sequence_Type(ISerializationContext context, VoidType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns UnaryMinusExpr
	 *     IfThenElseExpr returns UnaryMinusExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns UnaryMinusExpr
	 *     ChoiceExpr returns UnaryMinusExpr
	 *     ImpliesExpr returns UnaryMinusExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns UnaryMinusExpr
	 *     OrExpr returns UnaryMinusExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns UnaryMinusExpr
	 *     AndExpr returns UnaryMinusExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns UnaryMinusExpr
	 *     RelationalExpr returns UnaryMinusExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns UnaryMinusExpr
	 *     PlusExpr returns UnaryMinusExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns UnaryMinusExpr
	 *     MultExpr returns UnaryMinusExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns UnaryMinusExpr
	 *     UnaryExpr returns UnaryMinusExpr
	 *     AccessExpr returns UnaryMinusExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns UnaryMinusExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns UnaryMinusExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns UnaryMinusExpr
	 *     TerminalExpr returns UnaryMinusExpr
	 *
	 * Constraint:
	 *     expr=UnaryExpr
	 */
	protected void sequence_UnaryExpr(ISerializationContext context, UnaryMinusExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.UNARY_MINUS_EXPR__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.UNARY_MINUS_EXPR__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExprAccess().getExprUnaryExprParserRuleCall_2_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns UnaryNegationExpr
	 *     IfThenElseExpr returns UnaryNegationExpr
	 *     IfThenElseExpr.IfThenElseExpr_1_0_0_0 returns UnaryNegationExpr
	 *     ChoiceExpr returns UnaryNegationExpr
	 *     ImpliesExpr returns UnaryNegationExpr
	 *     ImpliesExpr.BinaryExpr_1_0_0_0 returns UnaryNegationExpr
	 *     OrExpr returns UnaryNegationExpr
	 *     OrExpr.BinaryExpr_1_0_0_0 returns UnaryNegationExpr
	 *     AndExpr returns UnaryNegationExpr
	 *     AndExpr.BinaryExpr_1_0_0_0 returns UnaryNegationExpr
	 *     RelationalExpr returns UnaryNegationExpr
	 *     RelationalExpr.BinaryExpr_1_0_0_0 returns UnaryNegationExpr
	 *     PlusExpr returns UnaryNegationExpr
	 *     PlusExpr.BinaryExpr_1_0_0_0 returns UnaryNegationExpr
	 *     MultExpr returns UnaryNegationExpr
	 *     MultExpr.BinaryExpr_1_0_0_0 returns UnaryNegationExpr
	 *     UnaryExpr returns UnaryNegationExpr
	 *     AccessExpr returns UnaryNegationExpr
	 *     AccessExpr.RecordAccessExpr_1_0_0_0_0 returns UnaryNegationExpr
	 *     AccessExpr.RecordUpdateExpr_1_1_0_0_0 returns UnaryNegationExpr
	 *     AccessExpr.ArrayAccessExpr_1_2_0_0_0 returns UnaryNegationExpr
	 *     TerminalExpr returns UnaryNegationExpr
	 *
	 * Constraint:
	 *     expr=UnaryExpr
	 */
	protected void sequence_UnaryExpr(ISerializationContext context, UnaryNegationExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.UNARY_NEGATION_EXPR__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.UNARY_NEGATION_EXPR__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExprAccess().getExprUnaryExprParserRuleCall_1_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Uses
	 *     Uses returns Uses
	 *
	 * Constraint:
	 *     (elements+=DefineUseRef elements+=DefineUseRef*)
	 */
	protected void sequence_Uses(ISerializationContext context, Uses semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarBlock returns NoVarBlock
	 *
	 * Constraint:
	 *     {NoVarBlock}
	 */
	protected void sequence_VarBlock(ISerializationContext context, NoVarBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarBlock returns SomeVarBlock
	 *
	 * Constraint:
	 *     locals+=LocalArg*
	 */
	protected void sequence_VarBlock(ISerializationContext context, SomeVarBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VoidStatement
	 *     VoidStatement returns VoidStatement
	 *     Equation returns VoidStatement
	 *
	 * Constraint:
	 *     expr=Expr
	 */
	protected void sequence_VoidStatement(ISerializationContext context, VoidStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.VOID_STATEMENT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.VOID_STATEMENT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVoidStatementAccess().getExprExprParserRuleCall_0_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (cond=Expr block=StatementBlock)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.WHILE_STATEMENT__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.WHILE_STATEMENT__COND));
			if (transientValues.isValueTransient(semanticObject, LimpPackage.Literals.WHILE_STATEMENT__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LimpPackage.Literals.WHILE_STATEMENT__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getCondExprParserRuleCall_1_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getWhileStatementAccess().getBlockStatementBlockParserRuleCall_2_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
}
