package com.rockwellcollins.atc.limp.translate.lustre.utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import jkind.lustre.BinaryExpr;
import jkind.lustre.BinaryOp;
import jkind.lustre.BoolExpr;
import jkind.lustre.Equation;
import jkind.lustre.Expr;
import jkind.lustre.IdExpr;
import jkind.lustre.NamedType;
import jkind.lustre.Node;
import jkind.lustre.NodeCallExpr;
import jkind.lustre.UnaryExpr;
import jkind.lustre.UnaryOp;
import jkind.lustre.VarDecl;

/**
 * PLTL is a utility that generates some commonly used PLTL expressions as Lustre node because
 * we need them to generate some of our autogenerated properties.
 */
public class PLTL {

	/**
	 * Y is a pre operator with the initial value set to FALSE 
	 */
	public static Node Y() {
		String name = "Y";
		List<VarDecl> inputs = new ArrayList<>();
		List<VarDecl> locals = new ArrayList<>();
		List<VarDecl> outputs = new ArrayList<>();
		List<Equation> equations = new ArrayList<>();
		
		//inputs
		VarDecl signal = new VarDecl("signal", NamedType.BOOL);
		
		//outputs
		VarDecl holds = new VarDecl("holds", NamedType.BOOL);
		
		//equations
		Equation equation = new Equation(new IdExpr(holds.id), new BinaryExpr(new BoolExpr(false), BinaryOp.ARROW, new UnaryExpr(UnaryOp.PRE, new IdExpr(signal.id))));
		
		inputs.add(signal);
		outputs.add(holds);
		equations.add(equation);
		
		return new Node(name,inputs,outputs,locals,equations);
	}
	
	/**
	 * Y is a pre operator with the initial value set to TRUE 
	 */
	public static Node Z() {
		String name = "Z";
		List<VarDecl> inputs = new ArrayList<>();
		List<VarDecl> locals = new ArrayList<>();
		List<VarDecl> outputs = new ArrayList<>();
		List<Equation> equations = new ArrayList<>();
		
		//inputs
		VarDecl signal = new VarDecl("signal", NamedType.BOOL);
		
		//outputs
		VarDecl holds = new VarDecl("holds", NamedType.BOOL);
		
		//equations
		Equation equation = new Equation(new IdExpr(holds.id), new BinaryExpr(new BoolExpr(true), BinaryOp.ARROW, new UnaryExpr(UnaryOp.PRE, new IdExpr(signal.id))));
		
		inputs.add(signal);
		outputs.add(holds);
		equations.add(equation);
		
		return new Node(name,inputs,outputs,locals,equations);
	}
	
	/**
	 * H is the node that implements Historically. Historically EXPR must be true on the current step and every previous step.
	 */
	public static Node H() {
		String name = "H";
		List<VarDecl> inputs = new ArrayList<>();
		List<VarDecl> locals = new ArrayList<>();
		List<VarDecl> outputs = new ArrayList<>();
		List<Equation> equations = new ArrayList<>();
		
		//inputs
		VarDecl signal = new VarDecl("signal", NamedType.BOOL);
		
		//outputs
		VarDecl holds = new VarDecl("holds", NamedType.BOOL);
		
		List<Expr> args = new ArrayList<>();
		args.add(new IdExpr(holds.id));
		
		//equations
		Equation equation = new Equation(new IdExpr(holds.id), new BinaryExpr(new IdExpr(signal.id), BinaryOp.AND, new NodeCallExpr("Z",args)));
		
		inputs.add(signal);
		outputs.add(holds);
		equations.add(equation);
		
		return new Node(name,inputs,outputs,locals,equations);
	}
	
	/**
	 * O is the node that implements Once. Once EXPR must be true at least once on the current step and every previous step. 
	 */
	public static Node O() {
		String name = "O";
		List<VarDecl> inputs = new ArrayList<>();
		List<VarDecl> locals = new ArrayList<>();
		List<VarDecl> outputs = new ArrayList<>();
		List<Equation> equations = new ArrayList<>();
		
		//inputs
		VarDecl signal = new VarDecl("signal", NamedType.BOOL);
		
		//outputs
		VarDecl holds = new VarDecl("holds", NamedType.BOOL);
		
		List<Expr> args = new ArrayList<>();
		args.add(new IdExpr(holds.id));
		
		//equations
		Equation equation = new Equation(new IdExpr(holds.id), new BinaryExpr(new IdExpr(signal.id), BinaryOp.OR, new NodeCallExpr("Y",args)));
		
		inputs.add(signal);
		outputs.add(holds);
		equations.add(equation);
		
		return new Node(name,inputs,outputs,locals,equations);
	}
	
	/**
	 * S is the node that implements Since. 
	 */
	public static Node S() {
		String name = "S";
		List<VarDecl> inputs = new ArrayList<>();
		List<VarDecl> locals = new ArrayList<>();
		List<VarDecl> outputs = new ArrayList<>();
		List<Equation> equations = new ArrayList<>();
		
		//inputs
		VarDecl a = new VarDecl("a", NamedType.BOOL);
		VarDecl b = new VarDecl("b", NamedType.BOOL);
		
		//outputs
		VarDecl holds = new VarDecl("holds", NamedType.BOOL);
		
		List<Expr> args = new ArrayList<>();
		args.add(new IdExpr(holds.id));
		
		//equations
		Equation equation = new Equation(new IdExpr(holds.id), new BinaryExpr(new IdExpr(b.id), BinaryOp.OR, new BinaryExpr(new IdExpr(a.id), BinaryOp.AND, new NodeCallExpr("Y",args))));
		
		inputs.add(a);
		inputs.add(b);
		
		outputs.add(holds);
		equations.add(equation);
		
		return new Node(name,inputs,outputs,locals,equations);
	}
	
	/**
	 * T is the node that implements Trigger 
	 */
	public static Node T() {
		String name = "T";
		List<VarDecl> inputs = new ArrayList<>();
		List<VarDecl> locals = new ArrayList<>();
		List<VarDecl> outputs = new ArrayList<>();
		List<Equation> equations = new ArrayList<>();
		
		//inputs
		VarDecl a = new VarDecl("a", NamedType.BOOL);
		VarDecl b = new VarDecl("b", NamedType.BOOL);
		
		//outputs
		VarDecl holds = new VarDecl("holds", NamedType.BOOL);
		
		List<Expr> args = new ArrayList<>();
		args.add(new IdExpr(holds.id));
		
		//equations
		Equation equation = new Equation(new IdExpr(holds.id), new BinaryExpr(new IdExpr(b.id), BinaryOp.AND, new BinaryExpr(new IdExpr(a.id), BinaryOp.OR, new NodeCallExpr("Z",args))));
		
		inputs.add(a);
		inputs.add(b);
		
		outputs.add(holds);
		equations.add(equation);
		
		return new Node(name,inputs,outputs,locals,equations);
	} 

	public static Map<String,Node> getAllPLTL() {
		List<Node> nodes = new ArrayList<>();
		Map<String,Node> map = new HashMap<>();
		
		nodes.add(Y());
		nodes.add(Z());
		nodes.add(H());
		nodes.add(O());
		nodes.add(S());
		nodes.add(T());

		for(Node n : nodes) {
			map.put(n.id, n);
		}
		
		return map;
	}
}
